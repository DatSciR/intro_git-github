---
title: | 
  | ![](images/UCM-Logo.png){width=80%,fig-align="right"} Aplicaciones bioinform√°ticas en biodiversidad, ecolog√≠a y evoluci√≥n
subtitle: "Ciencia reproducible con Git, GitHub y Quarto"
author:
  - name: Ver√≥nica Cruz-Alonso
    affiliations:
      - Universidad de Alcal√°
  - name: Julen Astigarraga
    affiliations:
      - Lund University
date: today
date-format: "DD/MM/YYYY"
toc: true
toc-depth: 4
toc-title: "√çndice"
format:
  html:
    link-external-newwindow: true
    # css: styles.css
  gfm: default
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
bibliography: references.bib
---

# Objetivos

-   Comprender la importancia de los flujos de an√°lisis reproducibles.

-   Comprender la funcionalidad y potencialidad de Git y GitHub en an√°lisis cient√≠ficos.

-   Comprender el flujo de trabajo entre Git, GitHub y RStudio.

-   Aprender a trabajar colaborativamente con Git y GitHub.

-   Aprender las bases de la programaci√≥n literaria en R.

-   Aprender los fundamentos b√°sicos de Quarto.

-   Generar documentos reproducibles en R.

# Introducci√≥n

Git (<https://git-scm.com/>) y GitHub ([https://github.com/](#0){.uri}) est√°n ganando cada vez m√°s importancia en diversos campos de estudio a medida que el volumen de datos aumenta y los an√°lisis se hacen m√°s complejos. Aprenderemos c√≥mo Git puede usarse para controlar la trazabilidad de los cambios realizados en proyectos o archivos y veremos c√≥mo este control de versiones es especialmente √∫til en proyectos colaborativos mediante el uso de un servidor de alojamiento en l√≠nea como GitHub.

Aunque existen multitud de manuales disponibles gratuitamente sobre c√≥mo utilizar Git y GitHub, estas herramientas son complejas. El prop√≥sito original de Git era ayudar a grupos de desarrolladores inform√°ticos a trabajar en colaboraci√≥n en grandes proyectos de software, por lo que puede resultar enrevesado, hay m√∫ltiples soluciones para el mismo problema y tiene una curva de aprendizaje pronunciada. Sin embargo, Git y GitHub nos pueden ayudar a solucionar algunos problemas comunes derivados de la creaci√≥n de diferentes versiones que pueden ser un poco molestos:

\- Sobreescritura de un archivo

\- Versiones finales infinitas

!["FINAL.doc"](images/FINALdoc.png)

\- Trabajo por error en una versi√≥n que no era la final

\- Creaci√≥n de copias "en conflicto" cuando dos personas trabajan a la vez

\- Ediciones sin control de cambios

![Ediciones sin control de cambios](images/tracker.png)\

## [Qu√© es Git](https://git-scm.com/)

Git es un sistema avanzado de **control de versiones** (como el "control de cambios" de Microsoft Word) **distribuido** [@blischak2016; @ram2013]. Git permite rastrear el progreso de un proyecto a lo largo del tiempo ya que hace "capturas" del mismo a medida que evoluciona y los cambios se van registrando. Este sistema permite ver qu√© cambios se hicieron, qui√©n los hizo y por qu√©, e incluso volver a versiones anteriores.

![Ejemplo de un proyecto rastreado por Git con indicaciones de c√≥mo se registran los cambios y la evoluci√≥n del proyecto, el autor o autora de los cambios (¬øqui√©n?), el momento en que se han registrado (¬øcu√°ndo?), en qu√© documentos o l√≠neas se han producido cambios (¬ød√≥nde?) y qu√© ha cambiado (¬øqu√©?)](images/git.jpg)

Adem√°s, Git facilita el trabajo en paralelo de varios participantes. Mientras que en otros sistemas de control de versiones (p. ej. Subversion (SVN, <https://subversion.apache.org/>) o Concurrent Versions System (CVS, <http://cvs.nongnu.org/>)) hay un servidor central y cualquier cambio hecho por un usuario se sincroniza con este servidor y de ah√≠ con el resto de usuarios, Git es un control de versiones distribuido que permite a todos los usuarios trabajar en el proyecto paralelamente e ir haciendo "capturas" del trabajo de cada uno para luego unirlos. Otras alternativas de control de versiones distribuido comparables a Git son Mercurial (<https://www.mercurial-scm.org/>) o Bazaar (<https://bazaar.canonical.com/>), pero Git es con diferencia el m√°s utilizado.

![Interacci√≥n entre Git y GitHub. Git, al ser un control de versiones distribuido, permite que todos los usuarios trabajen paralelamente sin interferir en el trabajo de los dem√°s. Luego cada usuario sincroniza su trabajo con la copia principal del proyecto ubicado en GitHub](images/conexiones.jpg){fig-align="center"}

Git surge en 2005, tras la ruptura de la relaci√≥n entre la comunidad que estaba desarrollando Linux y la empresa comercial que desarrollaba BitKeeper (DVCS). En ese momento BitKeeper dej√≥ de ser gratuita y esto llev√≥ a la comunidad de desarrolladores de Linux (y en particular a Linus Torvalds, el creador de Linux) a desarrollar su propia herramienta para el control de versiones bas√°ndose en su experiencia al utilizar BitKeeper. Algunos de los objetivos del nuevo sistema eran velocidad, dise√±o sencillo, gran soporte para el desarrollo no lineal (ramas), sistema distribuido y capacidad para manejar grandes bases de datos. Por tanto, el prop√≥sito original de Git era ayudar a grupos de desarrolladores inform√°ticos a trabajar en colaboraci√≥n en grandes proyectos de software. En este sentido, veremos que hay m√∫ltiples soluciones para un mismo problema y que la curva de aprendizaje para no desarrolladores puede ser pronunciada.

## [Qu√© es GitHub](https://github.com/)

GitHub es un servidor de alojamiento en l√≠nea o repositorio remoto para albergar proyectos basados en Git que permite la colaboraci√≥n entre diferentes usuarios o con uno mismo [@galeano2018; @perez-riverol2016]. Un repositorio es un directorio donde desarrollar un proyecto que contiene todos los archivos necesarios para el mismo. Aunque existen distintos repositorios remotos (p. ej. GitLab, <https://gitlab.com/>, o Bitbucket, <https://bitbucket.org/>) con funcionalidad similar, GitHub es hoy en d√≠a el m√°s utilizado. GitHub registra el desarrollo de los proyectos de manera remota, permite compartir proyectos entre distintos usuarios y proporciona la seguridad de la nube entre otras funciones.

![P√°gina inicial de GitHub](images/github_pag_ini.JPG)

Cuando se trabaja en proyectos colaborativos, la base de la interacci√≥n entre Git y GitHub es que todos los colaboradores de un proyecto est√°n de acuerdo en que GitHub contiene la copia principal del proyecto, es decir, GitHub contiene la copia centralizada del control de versiones distribuido o descentralizado.

# Instalaci√≥n

### üìù**Ejercicio 1.1**

En este punto es necesario que tengas instalada la versi√≥n m√°s reciente de R (<https://cloud.r-project.org/>), RStudio (<https://www.rstudio.com/products/rstudio/download/>), Git (<https://happygitwithr.com/install-git.html>) y una cuenta en GitHub (<https://github.com/>) creada.

1.  Pres√©ntate a Git ([Chapter 7: Git-Intro](#0))

    ```{r config}
    #|eval: false  

    # install.packages("usethis") 
    # library(usethis) 
    # use_git_config(user.name = "Monchi", user.email = "monchi@example.org")
    ```

üí°**Debes usar el correo electr√≥nico asociado a tu cuenta de GitHub**

2.  En la terminal, compueba que has instalado Git correctamente:

    `git --version`

    Para ver el usuario utilizado para configurar Git:

    `git config user.name`

    Para ver a qu√© cuenta de correo est√° asociado Git:

    `git config user.email`

    Para ver tanto el usuario como el correo asociado:

    `git config --global --list`

‚ö°¬øQu√© es el *shell*? El *shell* (o terminal) es un programa en tu ordenador cuyo trabajo es ejecutar otros programas (ver <https://happygitwithr.com/shell.html#shell>). RStudio incorpora una terminal que se puede utilizar para interactuar con Git; sin embargo, tambi√©n incorpora una pesta√±a llamada "Git" que contiene las funcionalidades b√°sicas de Git y facilita mucho su uso.

![Terminal](images/terminal.png)

üí°Para la resoluci√≥n de problemas durante la instalaci√≥n recomendamos mirar aqu√≠: <https://happygitwithr.com/troubleshooting.html>

3.  Genera un PAT (*Personal Access Token*) para HTTPS

    Git puede comunicarse con un servidor remoto utilizando uno de los dos protocolos: HTTPS o SSH. Nosotros utilzaremos HTTPS con *personal access token* (PAT, <https://happygitwithr.com/https-pat.html>).

```{r token}
#|eval: false  

# install.packages("gitcreds") 
# library(gitcreds) 
# create_github_token() # generar un token, elegir temporalidad
# gitcreds_set() # acceder al Git credential store
```

üëÄ Conviene describir el prop√≥sito del token en el campo *Note*, porque se pueden tener varios PATs. No podr√°s volver a ver este token, as√≠ que no cierres ni salgas de la ventana del navegador hasta que almacenes el PAT localmente. ¬°Trata este PAT como una contrase√±a!

# Repositorios y proyectos

Un repositorio es como un "contenedor" donde desarrollar un proyecto.

Para crear un repositorio en GitHub damos a "*+ New repository*". Aqu√≠ se indica el nombre, una peque√±a descripci√≥n, y si quieres que sea p√∫blico o privado. Se recomienda iniciar el repositorio con un archivo "README" (*Initialize this repository with a README*) para recoger cualquier informaci√≥n esencial para el uso del repositorio (estructura, descripci√≥n m√°s detallada del contenido, etc.).

En RStudio, creamos un nuevo proyecto y lo conectamos al repositorio: File \> New project \> Version control \> Git \> copiar el URL del repositorio que hemos creado de GitHub (est√° en la p√°gina principal de nuestro repositorio, en "*clone or download*"). Seleccionamos el directorio local donde queremos guardar el proyecto y pulsamos en "*Create project*".

Si vamos al directorio local seleccionado, encontraremos la carpeta conectada a Git y GitHub que hemos creado en nuestro ordenador. Podemos copiar aqu√≠ todos los archivos que nos interesan para el proyecto (datos, im√°genes, etc).

üí°Para m√°s informaci√≥n sobre c√≥mo clonar el repositorio en GitHub (repositorio remoto) en nuestro ordenador (repositorio local) ver <https://happygitwithr.com/rstudio-git-github.html> para hacerlo desde RStudio y @galeano2018 para hacerlo mediante la l√≠nea de comandos.

üí°En caso de querer conectar un antiguo proyecto de RStudio a Git y GitHub, puedes seguir los pasos que se describen aqu√≠: <https://happygitwithr.com/existing-github-first.html>.

### üìù**Ejercicio 1.2**

1.  Crea un repositorio en GitHub y con√©ctalo a un nuevo proyecto de RStudio (esto generar√° un repositorio (carpeta) en tu ordenador en la ubicaci√≥n que hayas especificado). Incluir un archivo "*.gitignore"*

2.  Crea un nuevo script de R en el directorio de trabajo (es decir, crea un script de R y gu√°rdalo dentro del repositorio que has creado)

3.  En RStudio ve a la pesta√±a Git para ver todos los documentos que han sido identificados por Git

![Git en RStudio](images/clipboard-1722222267.png)\

### Git ignore

Al crear un repositorio se recomienda crear un archivo "*.gitignore*". Este archivo contendr√° los nombres o extensiones de los archivos del proyecto que por defecto no queremos compartir aunque est√©n en el repositorio local (p. ej., el archivo "*.Rhistory*" que RStudio crea por defecto). Es una buena pr√°ctica ignorar archivos que no sean √∫tiles para el resto de colaboradores as√≠ como archivos muy pesados (p. ej., una base de datos resultado de correr un script) para no subirlos y descargarlos continuamente de GitHub. Para a√±adir archivos al *gitignore* se puede utilizar el bot√≥n derecho del rat√≥n sobre el archivo en la pesta√±a Git de RStudio pero tambi√©n se puede a√±adir el nombre del archivo que desamos ignorar en el archivo "*.gitignore*" manualmente.

### üìù**Ejercicio 1.3**

1.  A√±ade el archivo .Rproj de tu proyecto al archivo *.gitignore.*

2.  Crea una carpeta llamada "datos" en tu directorio de trabajo. A√±adela al *.gitignore* y guarda. ¬øQu√© ha pasado en la pesta√±a Git?

### Estructura del repositorio de GitHub

En la p√°gina principal del repositorio en GitHub podemos encontrar las siguientes pesta√±as:

-   **Code**: contenido del proyecto

-   **Issues**: foro del proyecto para comentar fallos, tareas pendientes, hacer peticiones a los desarrolladores, preguntar dudas, etc. Se pueden asignar tareas o preguntas a los miembros del proyecto escribiendo "\@" antes del nombre del colaborador. Una vez resuelto, el issue se cierra (*Close issue*).

-   **Pull requests**: veremos m√°s adelante para qu√© sirve.

-   **Actions**: son peque√±as aplicaciones que realizan alguna acci√≥n cada vez que se sube un commit (p. ej. tests).

-   **Projects**: es como una hoja de c√°lculo con tareas, encargados, deadlines, status, etc. que se integra con las incidencias y solicitudes de incorporaci√≥n de cambios para ayudar a planificar las tareas y realizar el seguimiento del trabajo.

-   **Wiki**: es un espacio para documentar el proyecto (hoja de ruta, estado, documentaci√≥n detallada...).

-   **Security**: opciones de seguridad.

-   **Insights**: estad√≠sticas del proyecto.

-   **Settings**

![Repositorio en GitHub destacando algunas pesta√±as importantes](images/github_repositorio.JPG)

# GitHub: la red social

GitHub no es s√≥lo un repositorio remoto donde almacenar diferentes versiones de tu trabajo o desarrollar proyectos colaborativos, si no que tambi√©n es una red de encuentro para programadores. Como en otras redes puedes cotillear perfiles, seguir a ciertas personas, tener seguidores, guardar proyectos que te gustan‚Ä¶

Con el buscador (üîç) puedes buscar aquellos contenidos que te interesan. La b√∫squeda est√° organizada por categor√≠as (*Repositories, Commits, Issues, Users*‚Ä¶) lo que facilita encontrar lo que buscas. Para seguir a un usuario tienes la opci√≥n *Follow*. Pulsando *Star*‚≠ê puedes guardar un enlace a cualquier repositorio en tu cuenta de GitHub y con *Fork* estar√≠as guardando una copia con la que puedes interaccionar. Con *Watch*üëÅÔ∏è puedes hacer un seguimiento de un repositorio. *Download* te permite guardar una copia de cualquier repositorio p√∫blico en tu ordenador.

# Flujo de trabajo en Git y GitHub

Git es capaz de rastrear todos los archivos contenidos en un repositorio. Para comprender c√≥mo Git registra los cambios y c√≥mo podemos compartir dichos cambios con nuestros colaboradores es importante entender c√≥mo se estructura Git y c√≥mo se sincroniza con GitHub. Hay cuatro "zonas" de trabajo:

1.  **Directorio de trabajo (*working directory*):** es donde se est√° trabajando. Esta zona se sincroniza con los archivos locales del ordenador.

2.  **√Årea de preparaci√≥n (*staging area* o *Index*):** es la zona intermedia entre el directorio de trabajo y el repositorio local de Git. Es la zona de borradores. El usuario debe seleccionar los archivos que se van a registrar en la siguiente "captura" de Git.

3.  **Repositorio local (*local repository* o *HEAD*):** es donde se registran todos los cambios capturados por Git en tu ordenador.

4.  **Repositorio remoto (*remote repository*):** es donde se registran todos los cambios capturados por Git en la nube (GitHub).

![Representaci√≥n gr√°fica de las diferentes zonas de trabajo en Git y GitHub: directorio de trabajo, √°rea de preparaci√≥n o Index, repositorio local o HEAD, y repositorio remoto. Imagen de fondo de Philip Brookes (https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode)](images/arboles.jpg)

## ¬øC√≥mo moverse de una zona a otra?

Se puede hacer mediante l√≠nea de comandos en la terminal y tambi√©n mediante la pesta√±a integrada en RStudio, pero el proceso es el mismo.

![Opciones de Git en RStudio](images/git_RStudio.png){alt="Opciones de Git en RStudio" fig-align="center" width="486"}

Al principio todos los cambios realizados aparecen en amarillo porque Git no sabe que hacer con ellos. Estamos en el directorio de trabajo y puede que no nos interese guardar todos los cambios para el futuro.

Para a√±adir un cambio del directorio de trabajo al √°rea de preparaci√≥n hay que utilizar `git add` (en la pesta√±a Git de RStudio se hace seleccionando el archivo). Este comando indica a Git que se quieren incluir las actualizaciones de alg√∫n archivo en la pr√≥xima "captura" del proyecto y que Git las registre. Sin embargo, `git add` no afecta al repositorio local.

-   `git add <nombre de archivo>`: a√±ade una actualizaci√≥n de alg√∫n archivo del directorio de trabajo al √°rea de preparaci√≥n.

Para registrar los cambios que nos interesen hay que utilizar `git commit` (en la pesta√±a Git de RStudio se hace clickando el bot√≥n "*Commit*"). Al ejecutar `git commit` se hace una "captura" del estado del proyecto. Junto con el *commit* se a√±ade un mensaje con una peque√±a explicaci√≥n de los cambios realizados y por qu√© (p. ej. "incluyo las referencias formateadas"). Cada `git commit` tiene un SHA (*Secure Hash Algorithm*) que es un c√≥digo alfanum√©rico que identifica inequ√≠vocamente ese *commit* (p. ej. 1d21fc3c33cxxc4aeb7823400b9c7c6bc2802be1). Parece dif√≠cil de entender, pero no te preocupes, s√≥lo tienes que recordar los siete primeros d√≠gitos 1d21fc3 üòÆ(es broma). Con el SHA siempre se pueden ver los cambios que se hicieron en ese *commit* y volver a esa versi√≥n f√°cilmente.

-   `git commit -m "mensaje corto y descriptivo"`

![Commit en RStudio](images/commit_RStudio.png){alt="Commit en RStudio" fig-align="center" width="545"}

üí°Usar `git commit` es para el proyecto como usar anclajes cuando estamos escalando una pared de roca. Desarrollar un script sin commits es como escalar sin asegurarse: puedes avanzar mucho m√°s r√°pido a corto plazo, pero a largo plazo las probabilidades de fallo catastr√≥fico son altas. Por otro lado, hacer muchos commits va a ralentizar tu progreso. Lo mejor: usar m√°s commits cuando est√°s en un territorio incierto o peligroso.

![Lineas de trabajo (cuerdas) aseguradas con varios commits (anclajes)](images/climbing.png){alt="Lineas de trabajo (cuerdas) aseguradas con varios commits (anclajes)"}

Por √∫ltimo, `git push` permite subir los cambios que hemos hecho a GitHub y quedar√°n visibles para nuestros colaboradores (en la pesta√±a Git de RStudio se hace clickando el bot√≥n "*Push*"). B√°sicamente, `git commit` registra los cambios en el repositorio local y `git push` actualiza el repositorio remoto con los cambios y archivos asociados.

Cuando se retoma un proyecto tras horas, d√≠as o incluso meses, con `git pull` se descargan todas las actualizaciones que haya en GitHub (nuestras o de nuestros colaboradores), que se fusionar√°n (*merge*) con el √∫ltimo *commit* en nuestro repositorio local (en la pesta√±a Git de RStudio se hace clickando el bot√≥n "*Pull*").

![Flujo de trabajo en Git y GitHub mostrando las diferentes zonas de trabajo y los comandos utilizados para la transici√≥n de una zona de trabajo a otra.](images/workflow_git_github.jpg)

Adem√°s de los botones principales anteriormente descritos, en la pesta√±a Git de RStudio podemos observar el bot√≥n "*Diff*" que muestra los cambios que se han hecho a cada archivo desde el √∫ltimo commit y las ramas (que lo explicaremos m√°s abajo). Clickando con el bot√≥n derecho del rat√≥n podemos abrir los archivos que han sido modificados mediante "*Open file*" y con el bot√≥n "*Revert*" volvemos al estado del √∫ltimo commit (‚ö†Ô∏ècuidado con esto porque te borrar√° los cambios realizados en tu directorio de trabajo).

### üìù**Ejercicio 1.4**

En el proyecto generado en el Ejercicio 1.2, guardad y subid los cambios realizados a GitHub (`git add` + `git commit` + `git push`)

üí°`git status`: muestra la rama en la que estamos y los cambios hechos y a√±adidos desde el √∫ltimo commit.

En el repositorio remoto de GitHub, en la pesta√±a *Code* podemos observar el contenido de nuestro proyecto, incluyendo cada *commit* realizado:

![](images/github_repositorio2.JPG)

## Navegar por el historial

El historial de un repositorio (*üïòXX commits*) contiene una lista de enlaces a todos los commits que se han realizado en cualquiera de las ramas. Dentro de cada *commit* se pueden ver los archivos a√±adidos o borrados en esa "captura" y las l√≠neas de c√≥digo a√±adidas (en verde) o borradas (en rojo) en cada archivo modificado. Adem√°s, en el historial, se pueden a√±adir comentarios en l√≠neas concretas de c√≥digo o comentarios generales al *commit* entero.

En GitHub tambi√©n se puede acceder a la historia de commits de cada archivo en concreto (*History*) y al autor de cada parte del c√≥digo (*Blame*).

El historial del proyecto y de los archivos tambi√©n es accesible a trav√©s de RStudio (üïí).

üí°M√°s informaci√≥n sobre como navegar en el pasado del proyecto aqu√≠: <https://happygitwithr.com/time-travel-see-past.html>

![Historial de un repositorio](images/hist.jpg){alt="Historial de un repositorio"}

üí°En los *issues* se puede referenciar a una l√≠nea concreta de c√≥digo de un estado concreto del proyecto entrando en el archivo en la pesta√±a *Code* y clickando en el n√∫mero de l√≠nea que se quiere comentar, o a un *commit* entero copiando el SHA.

üí°Si quiero volver atr√°s en el tiempo o si hago un cambio que no quiero ¬øc√≥mo lo puedo resolver? Hay m√∫ltiples opciones pero [aqu√≠](https://github.com/DatSciR/intro_git-github/blob/main/centra/dia3_comandos.md)(en la secci√≥n de "La he liado ¬øc√≥mo deshago los cambios?") detallamos tres: *restore*, *reset* y *revert*.

# Trabajo colaborativo

Aunque Git y GitHub facilitan el control de versiones de nuestros proyectos individuales, su m√°xima potencialidad se despliega al trabajar en equipo ya que facilitan el seguimiento del trabajo de todos los colaboradores y la integraci√≥n ordenada de cada parte en un producto final.

Para dar acceso de edici√≥n a tus colaboradores, en la p√°gina principal de nuestro proyecto en GitHub entramos en "*Settings -\> Access -\> Collaborators -\> Manage Access -\> Add people*". Los colaboradores pueden crear su copia local del proyecto de control de versiones clonando el repositorio remoto.

### üìùEjercicio 2.1

En equipos de 2 o 3 personas:

1.  El due√±o del repositorio invita al resto de integrantes del equipo a su proyecto
2.  Los colaboradores clonan el repositorio al que han sido invitados a su directorio de trabajo

## Ramificaci√≥n

Git permite crear una "rama" (*branch*) paralela al proyecto si se desea seguir una l√≠nea independiente de trabajo, bien por ser diferente de la principal (p. ej. probar un nuevo an√°lisis) o bien para desarrollar espec√≠ficamente una parte del proyecto (p. ej. trabajar s√≥lo en la escritura de los m√©todos de un art√≠culo mientras otros colaboradores trabajan en otras secciones). Las ramas permiten trabajar en el proyecto sin interferir con lo que est√°n haciendo los compa√±eros. En Git, una rama es un *commit* al que se le da un nombre y que contiene un "enlace" (puntero o *pointer*) a un SHA espec√≠fico que es el origen de la rama. La rama *main* es la rama por defecto cuando se crea un repositorio y a partir de ella se suelen crear las dem√°s.

Las ramas se pueden generar en la [terminal](https://github.com/DatSciR/intro_git-github/blob/main/centra/dia2_colaboracion.md) y en la pesta√±a Git de RStudio. En la pesta√±a Git se generan mediante el bot√≥n "*New Branch*". Al lado de "*New Branch"* podemos observar todas las ramas que contiene el repositorio y nos permite cambiar de rama f√°cilmente clickando en ellas.

![Proceso de creaci√≥n de la rama PPP y la rama monchi](images/ramas.png){alt="Proceso de creaci√≥n de la rama PPP y la rama monchi" fig-align="center"}

### üìùEjercicio 2.2

1.  Un integrante del equipo crea una rama en el proyecto en el que colabora

2.  Modifica la primera frase del archivo README.txt y sube los cambios al repositorio remoto

3.  Vuelve a la rama main y comprueba el archivo README.txt

![](images/github_code.png){fig-align="center" width="543"}

## ¬øC√≥mo se unen distintas ramas?

Cuando el trabajo desarrollado en una rama se da por finalizado hay que hacer la uni√≥n a la rama principal ("*main*"). Esto se puede hacer en la [terminal](https://github.com/DatSciR/intro_git-github/blob/main/centra/dia2_colaboracion.md) y con el bot√≥n "*pull request*" en la p√°gina del proyecto en GitHub siguiendo los pasos que se explican a continuaci√≥n.

![Proceso de creaci√≥n y uni√≥n de ramas. Ejemplo de uni√≥n (merge) de la rama monchi a la rama main](images/merge.jpg){alt="Proceso de creaci√≥n y uni√≥n de ramas. Ejemplo de uni√≥n (merge) de la rama monchi a la rama main"}

Una vez que hemos realizado los cambios que quer√≠amos en la rama y est√°n subidos a GitHub (`git add` + `git commit` + `git push`), en GitHub aparece la opci√≥n de "Compare & pull request". Aqu√≠ se genera el *pull request* ("*Create pull request*") a√±adiendo un mensaje para saber lo que se est√° uniendo. GitHub os indicar√° si existen conflictos o no. Si no existen conflictos, podr√©is realizar el *pull request* sin problema y, si existen conflictos, hay que resolverlos manualmente.

![](images/pullrequest1.jpg){fig-align="center"}

![](images/pullrequest1.1.jpg)

![Caracter√≠sticas del merge a realizar](images/pullrequest2.jpg){alt="Caracter√≠sticas del merge a realizar" fig-align="center"}

![](images/pullrequest3.jpg){fig-align="center"}

![Confirmacion y fin del proceso](images/pullrequest3.1.jpg){alt="Confirmacion y fin del proceso" fig-align="center"}

## Resoluci√≥n de conflictos

Git puede encontrar conflictos al fusionar ramas que hay que arreglar manualmente (GitHub os indicar√° "Can't automatically merge"). Esto ocurrir√° si en las dos ramas se han cambiado las mismas l√≠neas de un archivo. Hay que generar el pull request y "*Resolve conflicts*".

![Aparici√≥n de conflictos](images/cant_merge.png){alt="Aparici√≥n de conflictos"}

![Resoluci√≥n de conflictos](images/cant_merge2.png){alt="Resoluci√≥n de conflictos"}

Git muestra d√≥nde est√°n los conflictos as√≠:

`<<<<<<c√≥digo del main=======c√≥digo de la rama a unir>>>>>>`

![](images/cant_merge3.png)

Para solucionarlo hay que escoger los cambios de la rama principal o de la rama a unir seg√∫n corresponda. Una vez solucionados, Git permite completar el *merge* (es decir, un nuevo *commit* que contendr√° las ramas fusionadas). La mejor manera de evitar conflictos o por lo menos reducir su dificultad es realizar cambios peque√±os y sincronizar frecuentemente con GitHub, y tener una comunicaci√≥n fluida con los colaboradores.

### üìùEjercicio 2.3

1.  Un integrante del equipo modifica tambi√©n la primera frase del archivo README.txt en la rama main y sube los cambios al repositorio remoto. Esta frase hab√≠a sido previamente modificada en una rama en el ejercicio anterior.
2.  Un integrante del equipo combina la rama del ejercicio anterior con la rama principal (*main*) del proyecto.
3.  Resolved el conflicto (es decir, quedaos con los cambios que sirvan y subid los cambios al repositorio remoto).

üí°[Aqu√≠](https://github.com/DatSciR/intro_git-github/blob/main/centra/dia3_comandos.md) (en la secci√≥n de "Otros comandos √∫tiles") pod√©is ver c√≥mo borrar ramas y otros comandos √∫tiles

# Introduccti√≥n a Quarto y R Markdown

R Markdown (<https://rmarkdown.rstudio.com/>) empez√≥ en 2012 con el objetivo de facilitar la reproducibilidad en R. Ha sido desarrollado principalmente por [Yihui Xie](https://yihui.org/). R Markdown es un formato de archivo para crear documentos din√°micos con R que se apoya en [`knitr`](https://yihui.org/knitr/) (paquete para generaci√≥n de informes din√°micos en R) y [Pandoc](https://pandoc.org/) (conversor de documentos).

R Markdown utiliza **programaci√≥n literaria**, un paradigma de programaci√≥n creado por Donald E. Knuth que consiste en escribir en un lenguaje humano (p. ej. ingl√©s, castellano) con fragmentos de c√≥digo e instrucciones. R Markdown est√° escrito en Markdown y contiene partes de c√≥digo de R (o alg√∫n otro lenguaje de programaci√≥n) integrado.

Quarto (<https://quarto.org/>) es un sistema de publicaci√≥n cient√≠fica y t√©cnica de c√≥digo abierto construido sobre Pandoc. Convierte los formatos de texto plano o los formatos mixtos (p. ej. `.qmd`, `.Rmd`, `.md`, `.ipynb`) en informes est√°ticos PDF, word, HTML, etc. Puede entrelazar texto narrativo y c√≥digo para producir resultados con un formato elegante en forma de documentos, p√°ginas web, entradas de blog, libros, etc.

La extensi√≥n de Quarto es `.qmd` y utiliza filtros Lua que es el lenguaje de extensi√≥n de Pandoc (<https://quarto.org/docs/extensions/lua.html>). Para ello, Quarto utiliza un *engine* como `knitr` para ejecutar el c√≥digo y generar una salida temporal `.md`. El archivo `.md` se procesa mediante Pandoc y los filtros Lua de Quarto + Bootstrap CSS para HTML o LaTeX para PDF.

![Figura de jthomasmock.github.io/quarto-2hr-webinar](images/qmd-universe.png){alt="Figura de jthomasmock.github.io/quarto-2hr-webinar"}

La diferencia principal de Quarto respecto a R Markdown es que Quarto se ha generado para la colaboraci√≥n de m√°s de una comunidad (es decir, no solo usuarios de R o Python) y utiliza una sintaxis y formato compartido entre distintos lenguajes. Adem√°s, a medida que se a√±ad√≠an m√°s capacidades a R Markdown a trav√©s de paquetes externos de R, la sintaxis para las tareas b√°sicas se volv√≠a incoherente.

![Diagrama de funcionamiento de R Markdown. Figura de jthomasmock.github.io/quarto-2hr-webinar](images/knitr-diagram-rmd.png){alt="Diagrama de funcionamiento de R Markdown. Figura de jthomasmock.github.io/quarto-2hr-webinar"}

![Diagrama de funcionamiento de Quarto. Figura de jthomasmock.github.io/quarto-2hr-webinar](images/knitr-diagram-qmd.png){alt="Diagrama de funcionamiento de Quarto. Figura de jthomasmock.github.io/quarto-2hr-webinar"}

![Diagramas de funcionamiento de Quarto. Figura de jthomasmock.github.io/quarto-2hr-webinar](images/knitr-diagram-qmd-jupyter.png){alt="Diagramas de funcionamiento de Quarto. Figura de jthomasmock.github.io/quarto-2hr-webinar"}

Sea cual sea el sistema, Quarto y R Markdown aumentan de la eficiencia de trabajo (a medio-largo plazo), permiten centrarse en el texto sin perder tiempo en el dise√±o y permiten la producci√≥n de documentos de alta calidad.

## Fundamentos b√°sicos de Quarto

Para crear un archivo Quarto: *File -\> New File -\> Quarto document*. Debemos cambiar el modelo mental: ahora tendremos un documento fuente de texto plano y a partir de dicho documento generamos un documento renderizado. Estos archivos tienen tres componentes principales: (i) metadatos, (ii) texto, (iii) c√≥digo.

-   Metadatos: se escriben entre `` `---` `` al comienzo del archivo. Utiliza la sintaxis de [YAML](https://en.wikipedia.org/wiki/YAML) (Yet Another Markup Language). Se utiliza para evitar teclear manualmente todas las opciones que pueden afectar al c√≥digo, al contenido y al proceso de renderizado cada vez que renderizamos el archivo. ¬°La sangr√≠a es importante!

-   Texto: sintaxis Markdown. Markdown es un formato de texto plano que est√° dise√±ado para ser f√°cil de escribir y, a√∫n m√°s importante, f√°cil de leer.

-   C√≥digo (dos tipos):

    -   Code chunk (bloque de c√≥digo): se escribe ```` ```{r} codigo aqui``` ````; entre corchetes se indica el lenguaje. Se puede escribir manualmente, utilizar el atajo `Ctrl + Alt + I` (OS X: `Cmd + Option + I`), utilizar el comando `Insert -> Executable Cell` en la barra de herramientas del editor.

    -   Inline (en l√≠nea): se escribe `r "c√≥digo aqu√≠"`.

Para compilar un archivo, se ejecuta el bot√≥n de `Render` en RStudio (atajo: `Ctrl + Shift + K`; OS X `Cmd + Shift + K`), que llama a Quarto render en un trabajo de fondo. Esto evita que el renderizado abarrote la consola de R y as√≠ es f√°cil de detener.

üí°Con el editor visual de RStudio puedes ver en tiempo real c√≥mo es la conversi√≥n a word, HTML, etc.

üí°Opciones de ejecuci√≥n de los chunk: <https://quarto.org/docs/computations/execution-options.html>

Son compatibles con muchos lenguajes de programaci√≥n:

```{r reticulate}
#| echo: FALSE 
#| #| eval: TRUE 
#| #| warning: FALSE  

library(knitr)  
names(knitr::knit_engines$get())  
library(reticulate) # for python 
```

```{python}

x = "R mola!"  
print(x.split(" ")) 
```

```{r example}
#| warning: FALSE  
 
library(ggplot2) 
names(cars)  
ggplot(cars, aes(speed, dist)) +   
  geom_point() +   
  geom_smooth() 
```

Para buscar ayuda sobre como escribir el texto plano: *Help -\> Markdown Quick Reference* (italics, bold, headers, lists, links, images, R codes, tables, page break, superscripts...)

Referencias: [@blischak2016]

Formato: **negrita**, *cursiva*, sub√≠ndice~1~, super√≠ndice^2^, `c√≥digo`, [hiperv√≠nculo](https://bookdown.org/yihui/rmarkdown/markdown-syntax.html), notas al pie[^1]

[^1]: hello world

T√≠tulos: \# primer nivel; \## segundo nivel...

Listas y sublistas: \*, -, +

Citas:

> "R Markdown es maravilloso pero ojo con Quarto"
>
> --- Julen Astigarraga

F√≥rmulas:

$f(os) = {esta \choose gustando} esto^{?} (1-p)^{n-k}$

Comentarios:

<!--# esto es un comentario (atajo: Ctrl + Shift + C; OS X Cmd + Shift + C)-->

Tablas:

| Col1 | Col2 | Col3 |
|------|------|------|
|      |      |      |
|      |      |      |
|      |      |      |

: Esto es el pie de tabla

Figuras:

![Esto es el pie de figura](images/rmarkdown.png){alt="Esto es el pie de figura" width="30%"}

Videos:

::: {#fig-repro}
<iframe width="560" height="315" src="https://www.youtube.com/embed/s3JldKoA0zw">

</iframe>
:::

### üìùEjercicio 3.1

Genera un documento Quarto que est√© compuesto por al menos metadatos, c√≥digo y texto. Tambi√©n puedes a√±adir otros elementos, como tablas.

## Diferencias de Quarto respecto a R Markdown

Algunas diferencias entre Quarto y R Markdown en cuanto al c√≥digo (chunks):

-   Estructura de las opciones tipo `key: value`. Las [opciones de los chunks](https://quarto.org/docs/computations/execution-options.html) son similares a las de R Markdown.

-   `#|` sintaxis *(hash pipe)*. Esta es la sintaxis preferida de Quarto, aunque es compatible con la sintaxis anterior de R Markdown. El *hash pipe* le a√±ade m√°s consistencia entre los *engine* (Jupyter, knitr) y nos da m√°s control sobre el orden o espacio de las opciones del chunk (no est√° limitado a una l√≠nea de opciones). No hay ning√∫n atajo para un *hash pipe* pero si escribes uno los siguientes se a√±adir√°n autom√°ticamente cuando le das a enter.

-   Tabulaci√≥n enriquecida: inicias una palabra y tabulas para completar o `Ctrl + espacio` para ver todas las opciones disponibles.

```{r tabulacion}
#| eval: false 

2 * 2
```

-   Baterias incluidas: Quarto viene preinstalado con las √∫ltimas versiones de RStudio. No se tiene que instalar diferentes paquetes para crear diferentes formatos de salida: <https://quarto.org/docs/output-formats/all-formats.html>

-   Sintaxis compartida (elige tu propio editor y lenguaje preferido)

-   Mejores caracter√≠sticas y m√°s mejoras en el futuro (R Markdown todav√≠a se mantiene, pero la mayor√≠a de las nuevas caracter√≠sticas ser√°n incorporadas en Quarto)

### ¬øQu√© hago con mi `.Rmd` o `.ipynb` existentes?

¬°No pasa nada! La mayor√≠a de los `.Rmd` o `.ipynb` existentes se pueden convertir `as-is` a trav√©s de Quarto. Para hacerlo a trav√©s de la l√≠nea de comandos de la terminal se escribe:

`quarto render archivo.Rmd --to html`

Adem√°s existen distintas opciones para convertir archivos `.Rmd` a `.qmd`:

1.  Cambiar `.Rmd` a `.qmd` (esto siempre usar√° Quarto para la renderizaci√≥n)

2.  Cambiar la salida YAML: `html_document` a `format: html`

3.  `knitr::convert_chunk_header("archivo.Rmd", "archivo.qmd")`

No tienes que convertir la sintaxis de todos tus documentos antiguos. Quarto es compatible con versiones anteriores de R Markdown.

## Renderizaci√≥n

Existen tres formas para renderizar un documento en Quarto:

1.  Dentro de RStudio puedes usar el bot√≥n de *Render*

2.  En el terminal mediante quarto render: ü§ì

`quarto render archivo.qmd` (por defecto a HTML)

`quarto render archivo.qmd --to pdf`

`quarto render archivo.qmd --to docx`

`quarto --help`

üí°Sobre la importancia del YAML: las especificaciones del YAML se puede incluir tambi√©n en el terminal, pero si las hemos incluido en el YAML no tendremos que escribirlas cada vez.

`quarto render archivo.qmd --to html`

`quarto render archivo.qmd --to html -M code-fold:true`

3.  En la consola de R mediante el paquete `quarto`

`library(quarto)`

`quarto_render("archivo.qmd")`

`quarto_render("archivo.qmd", output_format = "pdf")`

## Generando el documento final

### Formato

T√≠tulos coloreados en azul, el texto no est√° con un espaciado doble, no hay n√∫meros de l√≠nea y... ¬°manuscrito rechazado! ¬°PERO NO VAMOS A EDITAR NADA EN WORD! Podemos asegurarnos de que el `.docx` creado tenga siempre el formato deseado utilizando una plantilla `.docx`. Para utilizarla, la plantilla debe colocarse en la misma carpeta que el archivo `.qmd` y debemos hacer un peque√±o ajuste en el YAML.

1.  Primero generamos la plantilla en el terminal:

    `quarto pandoc -o plantilla.docx --print-default-data-file reference.docx`

2.  Modificamos la plantilla generada como la queramos utilizando los estilos de Word.

3.  Lo a√±adimos al YAML

üí°F√≠jate en [este link](https://quarto.org/docs/output-formats/ms-word-templates.html) para saber como modificar una plantilla de Word.

```{r plantilla}
#| eval: false 
format:    
  docx:      
  reference-doc: plantilla.docx
```

### Referencias

Para introducir citas y referencias en nuestro texto en Quarto utilizaremos BibTeX y as√≠ evitaremos tener que hacerlo manualmente. Con BibTex, en lugar de escribir la cita se escribe una "clave" √∫nica (clave de citaci√≥n: @cita) cada vez que se cita una referencia. Esto permite a los autores cambiar los estilos de las referencias sin tener que reformatear nada manualmente (por ejemplo, si hay que enviar un manuscrito a una revista diferente para su publicaci√≥n).

üí° Recomendamos utilizar [Zotero](https://www.zotero.org/) como gestor bibliogr√°fico porque est√° incluido en RStudio, lo que facilita la inclusi√≥n de citas y referencias, pero se puede utilizar cualquier otro gestor.

Para a√±adir las referencias en alg√∫n lugar concreto del archivo (ver c√≥digo fuente):

::: {#refs}
:::

### üìùEjercicio 3.2

Genera una plantilla de formato y modifica los colores, tama√±o de los t√≠tulos, etc. Despu√©s, a√±adelo al YAML. A√±ade alguna referencia en el documento y renderizalo. Por √∫ltimo, sube el .qmd y la plantilla al repositorio sincronizado con Git y GitHub.

# Optimizaci√≥n de los flujos de trabajo

Google drive

```{r}

library(googledrive)

# drive_download(file = "https://docs.google.com/spreadsheets/d/10WaVa8EL971KOde4Y_iTgRBx61Wyr11s/edit?gid=102568759#gid=102568759",
#   path = "data/raw_data.xlsx", overwrite = TRUE)

```

## Colaboraci√≥n en documentos

\- En RStudio al parecer no se pueden visualizar los cambios por palabras a no ser que se usen herramientas externas o, la soluci√≥n que m√°s me ha convencido, pero a√∫n as√≠ es un poco rollo, que es poner en la terminal "git diff --word-diff". Con esto te va saliendo en la terminal todo el texto del archivo (dandole a intro todo el rato) con las palabras espec√≠ficas cambiadas resaltadas. Para salir de aqu√≠ en la terminal se pone ":q".

\- En GitHub, si le dais al historial del repositorio (donde pone "100 commits" en la imagen de abajo), est√°n todos los commits que se han ido haciendo. Si le dais a alguno, salen los cambios respecto al commit anterior en rojo y verde, pero con las palabras espec√≠ficas resaltadas en un tono m√°s oscuro (ver segunda imagen). As√≠ tendr√≠ais que ir cambiando entre GitHub y RStudio, pero igual es m√°s f√°cil.

# Algunos enlaces interesantes

**Ciencia reproducible**

-   [Ciencia reproducible: qu√©, por qu√©, c√≥mo](https://github.com/ecoinfAEET/Reproducibilidad)

**Control de versiones (Git)**

-   [Manual de referencia de Git](https://git-scm.com/docs)

-   [Software Carpentry](http://swcarpentry.github.io/git-novice/)

-   [Atlassian Bitbucket](https://www.atlassian.com/git/tutorials)

-   [Oh Shit, Git!?!](https://ohshitgit.com/)

-   [git - la gu√≠a sencilla](https://rogerdudler.github.io/git-guide/index.es.html)

-   [Pro Git](https://git-scm.com/book/es/v2)

**Integrar Git, GitHub y RStudio**

-   [Happy Git and GitHub for the useR](https://happygitwithr.com/)

-   [¬°Se puede entender c√≥mo funcionan Git y GitHub!](https://www.revistaecosistemas.net/index.php/ecosistemas/article/view/2332)

-   [Ciencia reproducible y colaborativa con R, Git y GitHub (DatSciR)](https://github.com/DatSciR/intro_git-github)

<details>

<summary>Session Info</summary>

```{r session-info}
Sys.time()
git2r::repository()
sessionInfo()
```

</details>
