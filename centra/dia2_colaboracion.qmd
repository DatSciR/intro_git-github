---
title: "Fundamentos de Git y GitHub y su aplicaci√≥n en proyectos colaborativos y reproducibles en R y RStudio"
author:
  - name: Julen Astigarraga
    affiliations:
      - Universidad de Alcal√°, Forest Ecology and Restoration Group
  - name: Ver√≥nica Cruz-Alonso
    affiliations:
      - Graduate School of Design, Harvard University
date: "`r Sys.Date()`"
format: 
  html: 
    toc: true
    toc-depth: 3
  gfm: default
editor_options: 
  chunk_output_type: console
bibliography: references.bib
---

Aunque Git y GitHub facilitan el control de versiones de nuestros proyectos individuales, su m√°xima potencialidad se despliega al trabajar en equipo ya que facilitan el seguimiento del trabajo de todos los colaboradores y la integraci√≥n ordenada de cada parte en un producto final.

# Integraci√≥n de colaboradores en el proyecto

Para dar acceso de edici√≥n a tus colaboradores, en la p√°gina principal de nuestro proyecto en GitHub entramos en "*Settings -\> Manage Access -\> Invite a collaborator*". Los colaboradores pueden crear su copia local del proyecto de control de versiones clonando el repositorio remoto.

### üìùEjercicio 2.1

1.  El due√±o del repositorio invita al resto de integrantes del equipo a su proyecto
2.  Los invitados clonan el repositorio al que han sido invitados a su directorio de trabajo

# Trabajo en paralelo

## Ramificaci√≥n

Git permite crear una "rama" (*branch*) paralela al proyecto si se desea seguir una l√≠nea independiente de trabajo, bien por ser diferente de la principal (p. ej. probar un nuevo an√°lisis) o bien para desarrollar espec√≠ficamente una parte del proyecto (p. ej. trabajar s√≥lo en la escritura de los m√©todos de un art√≠culo mientras otros colaboradores trabajan en otras secciones). Las ramas permiten trabajar en el proyecto sin interferir con lo que est√°n haciendo los compa√±eros. En Git, una rama es un *commit* al que le se le da un nombre y que contiene un "enlace" (puntero o *pointer*) a un SHA espec√≠fico que es el origen de la rama. La rama *main* es la rama por defecto cuando se crea un repositorio. Las dem√°s ramas se crean con `git checkout`.

-   `git checkout -b <branchname>`: crea una nueva rama y te cambia a ella.

-   `git checkout main`: para volver a la rama principal.

![Proceso de creaci√≥n de la rama *PPP* y la rama *monchi*](images/ramas.png){alt="Proceso de creaci√≥n de la rama PPP y la rama monchi"}

### üìùEjercicio 2.2

1.  Un integrante del equipo crea una rama en el proyecto en el que colabora

2.  Modifica la primera frase del archivo README.txt y sube los cambios al repositorio remoto

    üëÄ La primera vez que haces `git push` de una rama nueva en lugar de solamente utilizar `git push` utiliza `git push --set-upstream origin <nombre de la rama>`

3.  Vuelve a la rama main y comprueba el archivo README.txt

![](images/github_code.png)

## ¬øC√≥mo se unen distintas ramas?

Cuando el trabajo desarrollado en una rama se da por finalizado y se quiere unir a la rama principal ("*main*") hay que hacer la uni√≥n utilizando el comando `git merge`.

-   `git checkout <rama principal>`: posiciona el puntero de Git en el √∫ltimo commit de la rama principal a la que quiero unir la otra rama.

-   `git merge <rama a unir>`: fusiona los cambios hechos en las dos ramas.

Esto se puede hacer en el *shell* como acabamos de ver pero tambi√©n se puede hacer con el bot√≥n "*pull request*" en la p√°gina del proyecto en GitHub.

![Proceso de creaci√≥n y uni√≥n de ramas. Ejemplo de uni√≥n (*merge*) de la rama *monchi* a la rama *main*](images/merge.jpg){alt="Proceso de creaci√≥n y uni√≥n de ramas. Ejemplo de uni√≥n (merge) de la rama monchi a la rama main"}

Git puede encontrar conflictos al fusionar ramas que hay que arreglar manualmente. Esto ocurrir√° si en las dos ramas se han cambiado las mismas l√≠neas de un archivo. Git muestra d√≥nde est√°n los conflictos as√≠:

`<<<<<<c√≥digo del main=======c√≥digo de la rama a unir>>>>>>`

Para solucionarlo hay que escoger los cambios de la rama principal o de la rama a unir seg√∫n corresponda. Esto tambi√©n se puede hacer a trav√©s de un cliente de Git, como GitKraken (<https://www.gitkraken.com/>) o SourceTree (<https://www.sourcetreeapp.com/>). Una vez solucionados, Git permite completar el *merge* (es decir, un nuevo *commit* que contendr√° las ramas fusionadas). La mejor manera de evitar conflictos o por lo menos reducir su dificultad es realizar cambios peque√±os y sincronizar frecuentemente con GitHub.

‚ö°Si durante el merge y la resoluci√≥n de conflictos entras en p√°nico y no sabes si lo est√°s haciendo bien, siempre puedes volver al estado inicial antes de la fusi√≥n con `git merge --abort` (<https://happygitwithr.com/git-branches.html#bailing-out>).

### üìùEjercicio 2.3

1.  Un integrante del equipo modifica tambi√©n la primera frase del archivo README.txt en la rama main y sube los cambios al repositorio remoto. Esta frase hab√≠a sido previamente modificada en una rama en el ejercicio 2.2.
2.  Un integrante del equipo combina la rama del ejercicio 2.2 con la rama principal del proyecto.
3.  Resuelve el conflicto (es decir, qu√©date con los cambios que sirvan y sube los cambios al repositorio remoto).

# Utilidades de GitHub para el trabajo colaborativo

Como ya sabemos, GitHub es un servidor de alojamiento en linea para albergar proyectos basados en Git que permite la colaboraci√≥n entre diferentes usuarios o registrar versiones para uno mismo. En la clase anterior aprendimos como crear un repositorio y conectarlo a nuestro proyecto en RStudio, y hoy hemos visto como a√±adir colaboradores al proyecto, pero GitHub tiene muchas otras funcionalidades que facilitan el trabajo colaborativo.

## Repositorios: visi√≥n general

Recordemos que un repositorio es como un "contenedor" de nuestro proyecto. GitHub facilita el acceso al contenido con todas sus diferentes versiones. En la p√°gina principal del repositorio podemos encontrar las siguientes pesta√±as:

-   **Code**: contenido del proyecto

-   **Issues**: foro del proyecto para comentar fallos, tareas pendientes, hacer peticiones a los desarrolladores, preguntar dudas, etc.

-   **Pull requests**: facilita la comparaci√≥n y fusi√≥n (*merge*) de ramas desarrolladas de forma independiente.

-   **Actions**: son peque√±as aplicaciones que realizan alguna acci√≥n cada vez que se sube un commit (p. ej. tests).

-   **Projects**: es como una hoja de c√°lculo con tareas, encargados, deadlines, status, etc. que se integra con las incidencias y solicitudes de incorporaci√≥n de cambios para ayudar a planificar las tareas y realizar el seguimiento del trabajo.

-   **Wiki**: es un espacio para documentar el proyecto (hoja de ruta, estado, documentaci√≥n detallada...).

-   **Security**: opciones de seguridad.

-   **Insights**: estad√≠sticas del proyecto.

-   **Settings**

![Repositorio en GitHub destacando algunas pesta√±as importantes](images/github_repositorio.JPG){alt="Repositorio en GitHub destacando algunas pesta√±as importantes"}

En la pesta√±a *Code* encontramos el contenido de nuestro proyecto:

![Repositorio en GitHub destacando informaci√≥n importante](images/github_repositorio2.JPG){alt="Repositorio en GitHub destacando informaci√≥n importante"}

### üìùEjercicio 2.4

1.  Revisad vuestra cuenta de GitHub y comprobad los cambios que se han hecho en el proyecto, tanto en la rama main como en la rama creada en el ejercicio 2.2, qui√©n los ha hecho y las lineas que se han cambiado.

## Repositorios: historial

El historial de un repositorio (*üïòXX commits*) contiene una lista de enlaces a todos los commits que se han realizado en cualquiera de las ramas. Dentro de cada *commit* se pueden ver los archivos a√±adidos o borrados en esa "captura" y las l√≠neas de c√≥digo a√±adidas (en verde) o borradas (en rojo) en cada archivo modificado. Adem√°s, en el historial, se pueden a√±adir commentarios en l√≠neas concretas de c√≥digo o comentarios generales al commit entero.

En GitHub tambi√©n se puede acceder a la historia de commits de cada archivo en concreto (*History*) y al autor de cada parte del c√≥digo (*Blame*).

El historial del proyecto y de los archivos tambi√©n es accesible a trav√©s de RStudio (üïí).

‚ö°M√°s informaci√≥n sobre como navegar en el pasado del proyecto aqu√≠: <https://happygitwithr.com/time-travel-see-past.html>

![Historial de un repositorio](images/hist.jpg)

### üìùEjercicio 2.5

1.  ¬øCuantos commits se han hecho en el archivo README.txt?

## Issues

<!--# Explicar en GitHub -->

En el √°mbito de desarrolladores de software, los *issues* cumplen la funci√≥n de rastreadores de errores. A nosotros nos interesa m√°s utilizar los issues como una lista de tareas pendientes que permite incluir tareas para acordarte de lo que tienes que hacer, pero tambi√©n se pueden usar para hacer peticiones o preguntas a los desarrolladores.

Se pueden asignar tareas o preguntas a los miembros del proyecto escribiendo "\@" antes del nombre del colaborador.

En los *issues* tambi√©n se puede referenciar a una l√≠nea concreta de c√≥digo entrando en el archivo en la pesta√±a *Code* y clickando en el n√∫mero de l√≠nea que se quiere comentar, o un *commit* entero copiando el SHA que aparece en el historial.

Una vez resuelto, el issue se cierra (*Close issue*). Se puede conectar el issue con el commit correspondiente si en el mensaje del commit a√±ades `git commit -m "Close #XX"` (p. ej., "Close #1" para cerrar el "issue" n√∫mero 1).

### üìùEjercicio 2.6

1.  Publica un issue en el proyecto que incluya una lista de tareas asignando cada una a un colaborador
2.  Incluye una tarea que se refiera a una l√≠nea concreta del archivo README.txt

## Fork

GitHub contiene multitud de proyectos p√∫blicos que todos los usuarios pueden clonar y desarrollar independientemente. Al hacer una clonaci√≥n, se crea una ramificaci√≥n o copia del proyecto ("*fork*") que pasa a formar parte de tu cuenta de usuario en GitHub. En caso de que desees unir los cambios realizados al proyecto original, deber√°s solicitarlo (="*pull request*"). El due√±o del proyecto decide si acepta o no los cambios que propones.

<!--# Explicar en GitHub -->

# Git ignore

Al crear un repositorio se recomienda crear un archivo "*.gitignore*". Este archivo contendr√° los nombres o extensiones de los archivos del proyecto que por defecto no queremos compartir aunque est√©n en el repositorio local (p. ej., el archivo "*.Rhistory*" que RStudio crea por defecto). Es una buena pr√°ctica ignorar archivos que no sean √∫tiles pare el resto de colaboradores as√≠ como archivos muy pesados (p. ej., una base de datos resultado de correr un script) para no subirlos y descargarlos continuamente de GitHub. Para a√±adir archivos al *gitignore* se puede utilizar el bot√≥n derecho del rat√≥n sobre el archivo en la pesta√±a Git de RStudio pero tambi√©n se puede a√±adir el nombre del archivo que desamos ignorar en el archivo "*.gitignore*" manualmente.

### üìùEjercicio 2.7

1.  **Un miembro** del equipo descarga en su directorio de trabajo la √∫ltima versi√≥n del proyecto compartido si a√∫n no lo tiene (`git pull`).
2.  Crea un nuevo archivo en la carpeta en su ordenador.
3.  A√±ade el nombre del nuevo archivo a .gitignore.
4.  Sube todo al repositorio remoto y comprueba que archivos se han subido (`git add .` + `git commit -m "XX"` + `git push`).

üëÄSi has hecho un commit por error con archivos que quer√≠as ignorar, todav√≠a se puede arreglar. Primero tienes que decir a Git que deje de rastrear el archivo con `git rm --catched <archivo>`, despu√©s a√±adelo a *.gitignore* y haz un nuevo commit. El archivo no desaparecer√° de tu ordenador pero con `git pull` se eliminar√° del repositorio remoto.

# GitHub: la red social

GitHub no es s√≥lo un repositorio remoto donde almacenar diferentes versiones de tu trabajo o desarrollar proyectos colaborativos, si no que tambi√©n es una red de encuentro para programadores. Como en otras redes puedes cotillear perfiles, seguir a ciertas personas, tener seguidores, guardar proyectos que te gustan...

Con el buscador (üîç) puedes buscar aquellos contenidos que te interesan. La b√∫squeda est√° organizada por categor√≠as (*Repositories, Commits, Issues, Users*...) lo que facilita encontrar lo que buscas. Para seguir a un usuario tienes la opci√≥n *Follow*. Pulsando *Star*‚≠ê puedes guardar un enlace a cualquier repositorio en tu cuenta de GitHub y con *Fork* estar√≠as guardando una copia que te permite interaccionar con los due√±os del repositorio si quieres hacer alg√∫n cambio. Con *Watch*üëÅÔ∏è puedes hacer un seguimiento de un repositorio. *Download* te permite guardar una copia de cualquier repositorio p√∫blico en tu ordenador.

<details>

<summary>Session Info</summary>

```{r session-info}
Sys.time()
git2r::repository()
sessionInfo()
```

</details>
