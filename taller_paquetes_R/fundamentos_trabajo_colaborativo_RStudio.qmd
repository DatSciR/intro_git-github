---
title: "Fundamentos de Git y GitHub y su aplicaci칩n en proyectos colaborativos y reproducibles en R y RStudio"
author:
  - name: Julen Astigarraga
    affiliations:
      - Forest Ecology and Restoration Group, Universidad de Alcal치. 
  - name: Ver칩nica Cruz-Alonso
    affiliations:
      - Facultad de Ciencias Biol칩gicas. Universidad Complutense de Madrid 
date: "`r Sys.Date()`"
format: 
  html: 
    toc: true
    toc-depth: 3
  gfm: default
editor_options: 
  chunk_output_type: console
bibliography: references.bib
---

# Introducci칩n

El principal objetivo del taller es dar a conocer la estructura, funcionalidad y potencialidad de Git (<https://git-scm.com/>), as칤 como su interacci칩n con GitHub (<https://github.com/>), para el trabajo en proyectos colaborativos y reproducibles. Ambas herramientas est치n ganando cada vez m치s importancia en diversos campos de estudio a medida que el volumen de datos aumenta y los an치lisis se hacen m치s complejos. Aprenderemos c칩mo Git puede usarse para controlar la trazabilidad de los cambios realizados en proyectos o archivos y veremos c칩mo este control de versiones es especialmente 칰til en proyectos colaborativos mediante el uso de un servidor de alojamiento en l칤nea como GitHub. Aunque existen multitud de manuales disponibles gratuitamente sobre c칩mo utilizar Git y GitHub, estas herramientas son complejas. El prop칩sito original de Git era ayudar a grupos de desarrolladores inform치ticos a trabajar en colaboraci칩n en grandes proyectos de software, por lo que puede resultar enrevesado, hay m칰ltiples soluciones para el mismo problema y tiene una curva de aprendizaje pronunciada. Sin embargo, Git y GitHub nos pueden ayudar a solucionar algunos problemas comunes derivados de la creaci칩n de diferentes versiones que pueden ser un poco molestos:

\- Sobreescritura de un archivo

\- Versiones finales infinitas

!["FINAL.doc"](images/FINALdoc.png)

\- Trabajo por error en una versi칩n que no era la final

\- Creaci칩n de copias "en conflicto" cuando dos personas trabajan a la vez

\- Ediciones sin control de cambios

![Ediciones sin control de cambios](images/tracker.png)\

## [Qu칠 es Git](https://git-scm.com/)

Git es un sistema avanzado de control de versiones (como el "control de cambios" de Microsoft Word) distribuido [@blischak2016; @ram2013]. Git permite "rastrear" el progreso de un proyecto a lo largo del tiempo ya que hace "capturas" del mismo a medida que evoluciona y los cambios se van registrando. Este sistema permite ver qu칠 cambios se hicieron, qui칠n los hizo y por qu칠, e incluso volver a versiones anteriores. Adem치s, Git facilita el trabajo en paralelo de varios participantes. Mientras que en otros sistemas de control de versiones (p. ej. Subversion (SVN, <https://subversion.apache.org/>) o Concurrent Versions System (CVS, <http://cvs.nongnu.org/>)) hay un servidor central y cualquier cambio hecho por un usuario se sincroniza con este servidor y de ah칤 con el resto de usuarios, Git es un control de versiones distribuido que permite a todos los usuarios trabajar en el proyecto paralelamente e ir haciendo "capturas" del trabajo de cada uno para luego unirlos. Otras alternativas de control de versiones distribuido comparables a Git son Mercurial (<https://www.mercurial-scm.org/>) o Bazaar (<https://bazaar.canonical.com/>), pero Git es con diferencia el m치s utilizado.

![Ejemplo de un proyecto rastreado por Git con indicaciones de c칩mo se registran los cambios y la evoluci칩n del proyecto, el autor o autora de los cambios (쯤ui칠n?), el momento en que se han registrado (쯖u치ndo?), en qu칠 documentos o l칤neas se han producido cambios (쯗칩nde?) y qu칠 ha cambiado (쯤u칠?)](images/git.jpg)

## [Qu칠 es GitHub](https://github.com/)

GitHub es un servidor de alojamiento en l칤nea o repositorio remoto para albergar proyectos basados en Git que permite la colaboraci칩n entre diferentes usuarios o con uno mismo [@galeano2018; @perez-riverol2016]. Un repositorio es un directorio donde desarrollar un proyecto que contiene todos los archivos necesarios para el mismo. Aunque existen distintos repositorios remotos (p. ej. GitLab, <https://gitlab.com/>, o Bitbucket, <https://bitbucket.org/>) con funcionalidad similar, GitHub es hoy en d칤a el m치s utilizado. GitHub registra el desarrollo de los proyectos de manera remota, permite compartir proyectos entre distintos usuarios y proporciona la seguridad de la nube entre otras funciones. Cuando se trabaja en proyectos colaborativos, la base de la interacci칩n entre Git y GitHub es que todos los colaboradores de un proyecto est치n de acuerdo en que GitHub contiene la copia principal del proyecto, es decir, GitHub contiene la copia centralizada del control de versiones distribuido o descentralizado.

![P치gina inicial de GitHub](images/github_pag_ini.JPG)

![Interacci칩n entre Git y GitHub. Git, al ser un control de versiones distribuido, permite que todos los usuarios trabajen paralelamente sin interferir en el trabajo de los dem치s. Luego cada usuario sincroniza su trabajo con la copia principal del proyecto ubicado en GitHub](images/conexiones.jpg){fig-align="center" width="467"}

# Repositorios y proyectos

Un repositorio es como un "contenedor" donde desarrollar un proyecto.

Para crear un repositorio en GitHub damos a "*+ New repository*". Aqu칤 se indica el nombre, una peque침a descripci칩n, y si quieres que sea p칰blico o privado. Se recomienda iniciar el repositorio con un archivo "README" (*Initialize this repository with a README*) para recoger cualquier informaci칩n esencial para el uso del repositorio (estructura, descripci칩n m치s detallada del contenido, etc.).

En RStudio, creamos un nuevo proyecto y lo conectamos al repositorio: File -\> New project -\> Version control -\> Git -\> copiar el URL del repositorio que hemos creado de GitHub (est치 en la p치gina principal de nuestro repositorio, en "*clone or download*"). Seleccionamos el directorio local donde queremos guardar el proyecto y pulsamos en "*Create project*".

Si vamos al directorio local seleccionado, encontraremos la carpeta conectada a Git y GitHub que hemos creado en nuestro ordenador. Podemos copiar aqu칤 todos los archivos que nos interesan para el proyecto (datos, im치genes, etc).

丘멣ara m치s informaci칩n sobre c칩mo clonar el repositorio en GitHub (repositorio remoto) en nuestro ordenador (repositorio local) ver <https://happygitwithr.com/rstudio-git-github.html> para hacerlo desde RStudio y @galeano2018 para hacerlo mediante la l칤nea de comandos.

丘멘n caso de querer conectar un antiguo proyecto de RStudio a Git y GitHub, puedes seguir los pasos que se describen aqu칤: <https://happygitwithr.com/existing-github-first.html>.

## Estructura del repositorio de GitHub

En la p치gina principal del repositorio en GitHub podemos encontrar las siguientes pesta침as:

-   **Code**: contenido del proyecto

-   **Issues**: foro del proyecto para comentar fallos, tareas pendientes, hacer peticiones a los desarrolladores, preguntar dudas, etc. Se pueden asignar tareas o preguntas a los miembros del proyecto escribiendo "\@" antes del nombre del colaborador. Una vez resuelto, el issue se cierra (*Close issue*).

-   **Pull requests**: veremos m치s adelante para qu칠 sirve.

-   **Actions**: son peque침as aplicaciones que realizan alguna acci칩n cada vez que se sube un commit (p. ej. tests).

-   **Projects**: es como una hoja de c치lculo con tareas, encargados, deadlines, status, etc. que se integra con las incidencias y solicitudes de incorporaci칩n de cambios para ayudar a planificar las tareas y realizar el seguimiento del trabajo.

-   **Wiki**: es un espacio para documentar el proyecto (hoja de ruta, estado, documentaci칩n detallada...).

-   **Security**: opciones de seguridad.

-   **Insights**: estad칤sticas del proyecto.

-   **Settings**

![Repositorio en GitHub destacando algunas pesta침as importantes](images/github_repositorio.JPG){alt="Repositorio en GitHub destacando algunas pesta침as importantes"}

## Integraci칩n de Git en el proyecto de RStudio

![Git en RStudio](images/RStudio.JPG){alt="Git en RStudio"}

### 游닇**Ejercicio 1**

1.  Crea un repositorio en GitHub y con칠ctalo a un nuevo proyecto de RStudio (esto generar치 un repositorio (carpeta) en tu ordenador en la ubicaci칩n que hayas especificado). Incluir un archivo "*.gitignore"*

2.  Crea un nuevo script de R en el directorio de trabajo (es decir, crea un script de R y gu치rdalo dentro del repositorio que has creado)

3.  En RStudio ve a la pesta침a Git para ver todos los documentos que han sido identificados por Git

## Git ignore

Al crear un repositorio se recomienda crear un archivo "*.gitignore*". Este archivo contendr치 los nombres o extensiones de los archivos del proyecto que por defecto no queremos compartir aunque est칠n en el repositorio local (p. ej., el archivo "*.Rhistory*" que RStudio crea por defecto). Es una buena pr치ctica ignorar archivos que no sean 칰tiles pare el resto de colaboradores as칤 como archivos muy pesados (p. ej., una base de datos resultado de correr un script) para no subirlos y descargarlos continuamente de GitHub. Para a침adir archivos al *gitignore* se puede utilizar el bot칩n derecho del rat칩n sobre el archivo en la pesta침a Git de RStudio pero tambi칠n se puede a침adir el nombre del archivo que desamos ignorar en el archivo "*.gitignore*" manualmente.

# Flujo de trabajo en Git y GitHub

Git es capaz de rastrear todos los archivos contenidos en un repositorio. Para comprender c칩mo Git registra los cambios y c칩mo podemos compartir dichos cambios con nuestros colaboradores es importante entender c칩mo se estructura Git y c칩mo se sincroniza con GitHub. Hay cuatro "zonas" de trabajo:

1.  **Directorio de trabajo (*working directory*):** es donde se est치 trabajando. Esta zona se sincroniza con los archivos locales del ordenador.

2.  **츼rea de preparaci칩n (*staging area* o *Index*):** es la zona intermedia entre el directorio de trabajo y el repositorio local de Git. Es la zona de borradores. El usuario debe seleccionar los archivos que se van a registrar en la siguiente "captura" de Git.

3.  **Repositorio local (*local repository* o *HEAD*):** es donde se registran todos los cambios capturados por Git en tu ordenador.

4.  **Repositorio remoto (*remote repository*):** es donde se registran todos los cambios capturados por Git en la nube (GitHub).

![Representaci칩n gr치fica de las diferentes zonas de trabajo en Git y GitHub: directorio de trabajo, 치rea de preparaci칩n o Index, repositorio local o HEAD, y repositorio remoto. Imagen de fondo de Philip Brookes (<https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode>)](images/arboles.jpg){fig-align="center" width="469"}

## 쮺칩mo moverse de una zona a otra?

Se puede hacer mediante l칤nea de comandos en la terminal y tambi칠n mediante la pesta침a integrada en RStudio, pero el proceso es el mismo.

Al principio todos los cambios realizados aparecen en amarillo porque Git no sabe que hacer con ellos. Estamos en el directorio de trabajo y puede que no nos interese guardar todos los cambios para el futuro.

Para a침adir un cambio del directorio de trabajo al 치rea de preparaci칩n hay que utilizar `git add`. Este comando indica a Git que se quieren incluir las actualizaciones de alg칰n archivo en la pr칩xima "captura" del proyecto y que Git las registre. Sin embargo, `git add` no afecta al repositorio local.

Para registrar los cambios que nos interesen hay que utilizar `git commit`. Al ejecutar `git commit` se hace una "captura" del estado del proyecto. Junto con el *commit* se a침ade un mensaje con una peque침a explicaci칩n de los cambios realizados y por qu칠 (p. ej. "incluyo las referencias formateadas"). Cada `git commit` tiene un SHA (*Secure Hash Algorithm*) que es un c칩digo alfanum칠rico que identifica inequ칤vocamente ese *commit* (p. ej. 1d21fc3c33cxxc4aeb7823400b9c7c6bc2802be1). Con el SHA siempre se pueden ver los cambios que se hicieron en ese *commit* y volver a esa versi칩n f치cilmente.

Por 칰ltimo, `git push` permite subir los cambios que hemos hecho a GitHub y quedar치n visibles para nuestros colaboradores. B치sicamente, `git commit` registra los cambios en el repositorio local y `git push` actualiza el repositorio remoto con los cambios y archivos asociados.

Cuando se retoma un proyecto tras horas, d칤as o incluso meses, con `git pull` se descargan todas las actualizaciones que haya en GitHub (nuestras o de nuestros colaboradores), que se fusionar치n (*merge*) con el 칰ltimo *commit* en nuestro repositorio local.

![Flujo de trabajo en Git y GitHub mostrando las diferentes zonas de trabajo y los comandos utilizados para la transici칩n de una zona de trabajo a otra.](images/workflow_git_github.jpg)

![Opciones de Git en RStudio](images/git_RStudio.png){fig-align="center" width="486"}

![Commit en RStudio](images/commit_RStudio.png){fig-align="center" width="545"}

### 游닇**Ejercicio 2**

En el proyecto generado en el Ejercicio 1, guardad y subid los cambios realizados a GitHub (`git add` + `git commit` + `git push`)

丘멧sar `git commit` es para el proyecto como usar anclajes cuando estamos escalando una pared de roca. Desarrollar un script sin commits es como escalar sin asegurarse: puedes avanzar mucho m치s r치pido a corto plazo, pero a largo plazo las probabilidades de fallo catastr칩fico son altas. Por otro lado, hacer muchos commits va a ralentizar tu progreso. Lo mejor: usar m치s commits cuando est치s en un territorio incierto o peligroso.

![Lineas de trabajo (cuerdas) aseguradas con varios commits (anclajes)](images/climbing.png){alt="Lineas de trabajo (cuerdas) aseguradas con varios commits (anclajes)"}

En la pesta침a *Code* del repositorio de GitHub podemos observar el contenido de nuestro proyecto, incluyendo cada *commit* realizado:

![Repositorio en GitHub destacando informaci칩n importante](images/github_repositorio2.JPG){alt="Repositorio en GitHub destacando informaci칩n importante"}

## Navegar por el historial

El historial de un repositorio (*游뎾XX commits*) contiene una lista de enlaces a todos los commits que se han realizado en cualquiera de las ramas. Dentro de cada *commit* se pueden ver los archivos a침adidos o borrados en esa "captura" y las l칤neas de c칩digo a침adidas (en verde) o borradas (en rojo) en cada archivo modificado. Adem치s, en el historial, se pueden a침adir comentarios en l칤neas concretas de c칩digo o comentarios generales al commit entero.

En GitHub tambi칠n se puede acceder a la historia de commits de cada archivo en concreto (*History*) y al autor de cada parte del c칩digo (*Blame*).

El historial del proyecto y de los archivos tambi칠n es accesible a trav칠s de RStudio (游).

丘멠치s informaci칩n sobre como navegar en el pasado del proyecto aqu칤: <https://happygitwithr.com/time-travel-see-past.html>

![Historial de un repositorio](images/hist.jpg){alt="Historial de un repositorio"}

丘멘n los *issues* se puede referenciar a una l칤nea concreta de c칩digo de un estado concreto del proyecto entrando en el archivo en la pesta침a *Code* y clickando en el n칰mero de l칤nea que se quiere comentar, o un *commit* entero copiando el SHA.

# Trabajo colaborativo

Aunque Git y GitHub facilitan el control de versiones de nuestros proyectos individuales, su m치xima potencialidad se despliega al trabajar en equipo ya que facilitan el seguimiento del trabajo de todos los colaboradores y la integraci칩n ordenada de cada parte en un producto final.

Para dar acceso de edici칩n a tus colaboradores, en la p치gina principal de nuestro proyecto en GitHub entramos en "*Settings -\> Access -\> Collaborators -\> Manage Access -\> Add people*". Los colaboradores pueden crear su copia local del proyecto de control de versiones clonando el repositorio remoto.

### 游닇Ejercicio 3

En equipos de 2 o 3 personas:

1.  El due침o del repositorio invita al resto de integrantes del equipo a su proyecto
2.  Los colaboradores clonan el repositorio al que han sido invitados a su directorio de trabajo

## Ramificaci칩n

Git permite crear una "rama" (*branch*) paralela al proyecto si se desea seguir una l칤nea independiente de trabajo, bien por ser diferente de la principal (p. ej. probar un nuevo an치lisis) o bien para desarrollar espec칤ficamente una parte del proyecto (p. ej. trabajar s칩lo en la escritura de los m칠todos de un art칤culo mientras otros colaboradores trabajan en otras secciones). Las ramas permiten trabajar en el proyecto sin interferir con lo que est치n haciendo los compa침eros. En Git, una rama es un *commit* al que le se le da un nombre y que contiene un "enlace" (puntero o *pointer*) a un SHA espec칤fico que es el origen de la rama. La rama *main* es la rama por defecto cuando se crea un repositorio y a partir de ella se suelen crear las dem치s.

![Proceso de creaci칩n de la rama *PPP* y la rama *monchi*](images/ramas.jpg){alt="Proceso de creaci칩n de la rama PPP y la rama monchi" fig-align="center"}

### 游닇Ejercicio 4

1.  Un integrante del equipo crea una rama en el proyecto en el que colabora

2.  Modifica la primera frase del archivo README.txt y sube los cambios al repositorio remoto

3.  Vuelve a la rama main y comprueba el archivo README.txt

![](images/github_code.png){fig-align="center" width="543"}

## 쮺칩mo se unen distintas ramas?

Cuando el trabajo desarrollado en una rama se da por finalizado y se quiere unir a la rama principal ("*main*") hay que hacer la uni칩n.

![Proceso de creaci칩n y uni칩n de ramas. Ejemplo de uni칩n (*merge*) de la rama *monchi* a la rama *main*](images/merge.jpg){alt="Proceso de creaci칩n y uni칩n de ramas. Ejemplo de uni칩n (merge) de la rama monchi a la rama main"}

Esto se puede hacer con el bot칩n "*pull request*" en la p치gina del proyecto en GitHub siguiendo los pasos que se explican a continuaci칩n:

<!--# He hecho capturas de todos los pasos porque justo tenia mi rama sin unir, por si sirven para esta parte. Si no, se pueden quitar. Tambi칠n se peden orgaizar de otra manera. Tengo las imagenes en un ppt. Ahora se ven peque침as, pero prefiero que lo veas antes de dejarlo bonito -->

![](images/pullrequest1.jpg){fig-align="center"}

![Caracter칤sticas del *merge* a realizar](images/pullrequest2.jpg){fig-align="center"}

![Confirmacion y fin del proceso](images/pullrequest3.jpg)

## Resoluci칩n de conflictos

Git puede encontrar conflictos al fusionar ramas que hay que arreglar manualmente. Esto ocurrir치 si en las dos ramas se han cambiado las mismas l칤neas de un archivo. Git muestra d칩nde est치n los conflictos as칤:

<!--# Habr칤a que comprobar como salen los conflictos en Github o como va -->

`<<<<<<c칩digo del main=======c칩digo de la rama a unir>>>>>>`

Para solucionarlo hay que escoger los cambios de la rama principal o de la rama a unir seg칰n corresponda. Una vez solucionados, Git permite completar el *merge* (es decir, un nuevo *commit* que contendr치 las ramas fusionadas). La mejor manera de evitar conflictos o por lo menos reducir su dificultad es realizar cambios peque침os y sincronizar frecuentemente con GitHub.

### 游닇Ejercicio 5

1.  Un integrante del equipo modifica tambi칠n la primera frase del archivo README.txt en la rama main y sube los cambios al repositorio remoto. Esta frase hab칤a sido previamente modificada en una rama en el ejercicio 4.
2.  Un integrante del equipo combina la rama del ejercicio 4 con la rama principal (*main*) del proyecto.
3.  Resolved el conflicto (es decir, quedaos con los cambios que sirvan y subid los cambios al repositorio remoto).

# Algunos enlaces interesantes

**Ciencia reproducible**

-   [Ciencia reproducible: qu칠, por qu칠, c칩mo](https://github.com/ecoinfAEET/Reproducibilidad)

**Control de versiones (Git)**

-   [Manual de referencia de Git](https://git-scm.com/docs)

-   [Software Carpentry](http://swcarpentry.github.io/git-novice/)

-   [Atlassian Bitbucket](https://www.atlassian.com/git/tutorials)

-   [Oh Shit, Git!?!](https://ohshitgit.com/)

-   [git - la gu칤a sencilla](https://rogerdudler.github.io/git-guide/index.es.html)

-   [Pro Git](https://git-scm.com/book/es/v2)

**Integrar Git, GitHub y RStudio**

-   [Happy Git and GitHub for the useR](https://happygitwithr.com/)

**Ense침ar y aprender con GitHub**

-   [GitHub Education para profesores e investigadores](https://docs.github.com/en/education/explore-the-benefits-of-teaching-and-learning-with-github-education/use-github-in-your-classroom-and-research/about-github-education-for-educators-and-researchers)

<details>

<summary>Session Info</summary>

```{r session-info}
Sys.time()
git2r::repository()
sessionInfo()
```

</details>
