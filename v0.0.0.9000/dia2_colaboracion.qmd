---
title: "Fundamentos de Git y GitHub y su aplicaci칩n en proyectos colaborativos y reproducibles en R y RStudio"
author:
  - name: Julen Astigarraga
    affiliations:
      - Universidad de Alcal치, Forest Ecology and Restoration Group
  - name: Ver칩nica Cruz-Alonso
    affiliations:
      - Graduate School of Design, Harvard University
date: "`r Sys.Date()`"
format: 
  html: 
    toc: true
    toc-depth: 3
  gfm: default
editor_options: 
  chunk_output_type: console
bibliography: references.bib
---

Aunque Git y GitHub facilitan el control de versiones de nuestros proyectos individuales, su m치xima potencialidad se despliega al trabajar en equipo ya que facilitan el seguimiento del trabajo de todos los colaboradores y la integraci칩n ordenada de cada parte en un producto final.

# Integraci칩n de colaboradores en el proyecto

Para dar acceso de edici칩n a tus colaboradores, en la p치gina principal de nuestro proyecto en GitHub entramos en "*Settings -\> Manage Access -\> Invite a collaborator*". Los colaboradores pueden crear su copia local del proyecto de control de versiones clonando el repositorio remoto.

### 游닇Ejercicio 2.1

1.  El due침o del repositorio invita al resto de integrantes del equipo a su proyecto
2.  Los invitados clonan el repositorio al que han sido invitados a su directorio de trabajo

# Trabajo en paralelo

## Ramificaci칩n

Git permite crear una "rama" (*branch*) paralela al proyecto si se desea seguir una l칤nea independiente de trabajo, bien por ser diferente de la principal (p. ej. probar un nuevo an치lisis) o bien para desarrollar espec칤ficamente una parte del proyecto (p. ej. trabajar s칩lo en la escritura de los m칠todos de un art칤culo mientras otros colaboradores trabajan en otras secciones). Las ramas permiten trabajar en el proyecto sin interferir con lo que est치n haciendo los compa침eros. En Git, una rama es un *commit* al que le se le da un nombre y que contiene un "enlace" (puntero o *pointer*) a un SHA espec칤fico que es el origen de la rama. La rama *main* es la rama por defecto cuando se crea un repositorio. Las dem치s ramas se crean con `git checkout`.

-   `git checkout -b <branchname>`: crea una nueva rama y te cambia a ella.

-   `git checkout main`: para volver a la rama principal.

![Proceso de creaci칩n de la rama *PPP* y la rama *monchi*](images/ramas.png){alt="Proceso de creaci칩n de la rama PPP y la rama monchi"}

### 游닇Ejercicio 2.2

1.  Un integrante del equipo crea una rama en el proyecto en el que colabora

2.  Modifica la primera frase del archivo README.txt y sube los cambios al repositorio remoto

    游 La primera vez que haces `git push` de una rama nueva en lugar de solamente utilizar `git push` utiliza `git push --set-upstream origin <nombre de la rama>`

3.  Vuelve a la rama main y comprueba el archivo README.txt

![](images/github_code.png)

## 쮺칩mo se unen distintas ramas?

Cuando el trabajo desarrollado en una rama se da por finalizado y se quiere unir a la rama principal ("*main*") hay que hacer la uni칩n utilizando el comando `git merge`.

-   `git checkout <rama principal>`: posiciona el puntero de Git en el 칰ltimo commit de la rama principal a la que quiero unir la otra rama.

-   `git merge <rama a unir>`: fusiona los cambios hechos en las dos ramas.

Esto se puede hacer en el *shell* como acabamos de ver pero tambi칠n se puede hacer con el bot칩n "*pull request*" en la p치gina del proyecto en GitHub.

![Proceso de creaci칩n y uni칩n de ramas. Ejemplo de uni칩n (*merge*) de la rama *monchi* a la rama *main*](images/merge.jpg){alt="Proceso de creaci칩n y uni칩n de ramas. Ejemplo de uni칩n (merge) de la rama monchi a la rama main"}

Git puede encontrar conflictos al fusionar ramas que hay que arreglar manualmente. Esto ocurrir치 si en las dos ramas se han cambiado las mismas l칤neas de un archivo. Git muestra d칩nde est치n los conflictos as칤:

`<<<<<<c칩digo del main=======c칩digo de la rama a unir>>>>>>`

Para solucionarlo hay que escoger los cambios de la rama principal o de la rama a unir seg칰n corresponda. Esto tambi칠n se puede hacer a trav칠s de un cliente de Git, como GitKraken (<https://www.gitkraken.com/>) o SourceTree (<https://www.sourcetreeapp.com/>). Una vez solucionados, Git permite completar el *merge* (es decir, un nuevo *commit* que contendr치 las ramas fusionadas). La mejor manera de evitar conflictos o por lo menos reducir su dificultad es realizar cambios peque침os y sincronizar frecuentemente con GitHub.

丘멥i durante el merge y la resoluci칩n de conflictos entras en p치nico y no sabes si lo est치s haciendo bien, siempre puedes volver al estado inicial antes de la fusi칩n con `git merge --abort` (<https://happygitwithr.com/git-branches.html#bailing-out>).

### 游닇Ejercicio 2.3

1.  Un integrante del equipo modifica tambi칠n la primera frase del archivo README.txt en la rama main y sube los cambios al repositorio remoto. Esta frase hab칤a sido previamente modificada en una rama en el ejercicio 2.2.
2.  Un integrante del equipo combina la rama del ejercicio 2.2 con la rama principal del proyecto.
3.  Resuelve el conflicto (es decir, qu칠date con los cambios que sirvan y sube los cambios al repositorio remoto).

# Utilidades de GitHub para el trabajo colaborativo

Como ya sabemos, GitHub es un servidor de alojamiento en linea para albergar proyectos basados en Git que permite la colaboraci칩n entre diferentes usuarios o registrar versiones para uno mismo. En la clase anterior aprendimos como crear un repositorio y conectarlo a nuestro proyecto en RStudio, y hoy hemos visto como a침adir colaboradores al proyecto, pero GitHub tiene muchas otras funcionalidades que facilitan el trabajo colaborativo.

## Repositorios: visi칩n general

Recordemos que un repositorio es como un "contenedor" de nuestro proyecto. GitHub facilita el acceso al contenido con todas sus diferentes versiones. En la p치gina principal del repositorio podemos encontrar las siguientes pesta침as:

-   **Code**: contenido del proyecto

-   **Issues**: foro del proyecto para comentar fallos, tareas pendientes, hacer peticiones a los desarrolladores, preguntar dudas, etc.

-   **Pull requests**: facilita la comparaci칩n y fusi칩n (*merge*) de ramas desarrolladas de forma independiente.

-   **Actions**: son peque침as aplicaciones que realizan alguna acci칩n cada vez que se sube un commit (p. ej. tests).

-   **Projects**: es como una hoja de c치lculo con tareas, encargados, deadlines, status, etc. que se integra con las incidencias y solicitudes de incorporaci칩n de cambios para ayudar a planificar las tareas y realizar el seguimiento del trabajo.

-   **Wiki**: es un espacio para documentar el proyecto (hoja de ruta, estado, documentaci칩n detallada...).

-   **Security**: opciones de seguridad.

-   **Insights**: estad칤sticas del proyecto.

-   **Settings**

![Repositorio en GitHub destacando algunas pesta침as importantes](images/github_repositorio.JPG){alt="Repositorio en GitHub destacando algunas pesta침as importantes"}

En la pesta침a *Code* encontramos el contenido de nuestro proyecto:

![Repositorio en GitHub destacando informaci칩n importante](images/github_repositorio2.JPG){alt="Repositorio en GitHub destacando informaci칩n importante"}

### 游닇Ejercicio 2.4

1.  Revisad vuestra cuenta de GitHub y comprobad los cambios que se han hecho en el proyecto, tanto en la rama main como en la rama creada en el ejercicio 2.2, qui칠n los ha hecho y las lineas que se han cambiado.

## Repositorios: historial

El historial de un repositorio (*游뎾XX commits*) contiene una lista de enlaces a todos los commits que se han realizado en cualquiera de las ramas. Dentro de cada *commit* se pueden ver los archivos a침adidos o borrados en esa "captura" y las l칤neas de c칩digo a침adidas (en verde) o borradas (en rojo) en cada archivo modificado. Adem치s, en el historial, se pueden a침adir commentarios en l칤neas concretas de c칩digo o comentarios generales al commit entero.

En GitHub tambi칠n se puede acceder a la historia de commits de cada archivo en concreto (*History*) y al autor de cada parte del c칩digo (*Blame*).

El historial del proyecto y de los archivos tambi칠n es accesible a trav칠s de RStudio (游).

丘멠치s informaci칩n sobre como navegar en el pasado del proyecto aqu칤: <https://happygitwithr.com/time-travel-see-past.html>

![Historial de un repositorio](images/hist.jpg)

### 游닇Ejercicio 2.5

1.  쮺uantos commits se han hecho en el archivo README.txt?

## Issues

<!--# Explicar en GitHub -->

En el 치mbito de desarrolladores de software, los *issues* cumplen la funci칩n de rastreadores de errores. A nosotros nos interesa m치s utilizar los issues como una lista de tareas pendientes que permite incluir tareas para acordarte de lo que tienes que hacer, pero tambi칠n se pueden usar para hacer peticiones o preguntas a los desarrolladores.

Se pueden asignar tareas o preguntas a los miembros del proyecto escribiendo "\@" antes del nombre del colaborador.

En los *issues* tambi칠n se puede referenciar a una l칤nea concreta de c칩digo entrando en el archivo en la pesta침a *Code* y clickando en el n칰mero de l칤nea que se quiere comentar, o un *commit* entero copiando el SHA que aparece en el historial.

Una vez resuelto, el issue se cierra (*Close issue*). Se puede conectar el issue con el commit correspondiente si en el mensaje del commit a침ades `git commit -m "Close #XX"` (p. ej., "Close #1" para cerrar el "issue" n칰mero 1).

### 游닇Ejercicio 2.6

1.  Publica un issue en el proyecto que incluya una lista de tareas asignando cada una a un colaborador
2.  Incluye una tarea que se refiera a una l칤nea concreta del archivo README.txt

## Fork

GitHub contiene multitud de proyectos p칰blicos que todos los usuarios pueden clonar y desarrollar independientemente. Al hacer una clonaci칩n, se crea una ramificaci칩n o copia del proyecto ("*fork*") que pasa a formar parte de tu cuenta de usuario en GitHub. En caso de que desees unir los cambios realizados al proyecto original, deber치s solicitarlo (="*pull request*"). El due침o del proyecto decide si acepta o no los cambios que propones.

<!--# Explicar en GitHub -->

# Git ignore

Al crear un repositorio se recomienda crear un archivo "*.gitignore*". Este archivo contendr치 los nombres o extensiones de los archivos del proyecto que por defecto no queremos compartir aunque est칠n en el repositorio local (p. ej., el archivo "*.Rhistory*" que RStudio crea por defecto). Es una buena pr치ctica ignorar archivos que no sean 칰tiles pare el resto de colaboradores as칤 como archivos muy pesados (p. ej., una base de datos resultado de correr un script) para no subirlos y descargarlos continuamente de GitHub. Para a침adir archivos al *gitignore* se puede utilizar el bot칩n derecho del rat칩n sobre el archivo en la pesta침a Git de RStudio pero tambi칠n se puede a침adir el nombre del archivo que desamos ignorar en el archivo "*.gitignore*" manualmente.

### 游닇Ejercicio 2.7

1.  **Un miembro** del equipo descarga en su directorio de trabajo la 칰ltima versi칩n del proyecto compartido si a칰n no lo tiene (`git pull`).
2.  Crea un nuevo archivo en la carpeta en su ordenador.
3.  A침ade el nombre del nuevo archivo a .gitignore.
4.  Sube todo al repositorio remoto y comprueba que archivos se han subido (`git add .` + `git commit -m "XX"` + `git push`).

# GitHub: la red social

GitHub no es s칩lo un repositorio remoto donde almacenar diferentes versiones de tu trabajo o desarrollar proyectos colaborativos, si no que tambi칠n es una red de encuentro para programadores. Como en otras redes puedes seguir a ciertos perfiles, tener seguidores,

<!--# TERMINAR -->

Stars followers buscador

<details>

<summary>Session Info</summary>

```{r session-info}
Sys.time()
git2r::repository()
sessionInfo()
```

</details>
