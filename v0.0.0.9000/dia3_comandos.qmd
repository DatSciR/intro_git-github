---
title: "Fundamentos de Git y GitHub y su aplicaci√≥n en proyectos colaborativos y reproducibles en R y RStudio"
author:
  - name: Julen Astigarraga
    affiliations:
      - Universidad de Alcal√°, Forest Ecology and Restoration Group
  - name: Ver√≥nica Cruz-Alonso
    affiliations:
      - Graduate School of Design, Harvard University
date: "`r Sys.Date()`"
format: 
  html: 
    toc: true
    toc-depth: 3
  gfm: default
editor_options: 
  chunk_output_type: console
bibliography: references.bib
---

# Flujo de trabajo: repaso

Hay cuatro zonas en el flujo de trabajo de Git y GitHub: **directorio de trabajo, √°rea de preparaci√≥n, repositorio local** y **repositorio remoto**. Con `git pull` se descargan todas las actualizaciones del repositorio remoto al directorio de trabajo. Con `git add` se a√±aden los cambios en el directorio de trabajo al √°rea de preparaci√≥n. Para registrar los cambios en el repositorio local hay que utilizar `git commit` y, despu√©s, para subirlos al repositorio remoto `git push`.

‚ö°Usar `git commit` es para el proyecto como usar anclajes cuando estamos escalando una pared de roca. Desarrollar un script sin commits es como escalar sin asegurarse: puedes avanzar mucho m√°s r√°pido a corto plazo, pero a largo plazo las probabilidades de fallo catastr√≥fico son altas. Por otro lado, hacer muchos commits va a ralentizar tu progreso. Lo mejor: usar m√°s commits cuando est√°s en un territorio incierto o peligroso.

![Lineas de trabajo (cuerdas) aseguradas con varios commits (anclajes)](images/climbing.png)

### üìùEjercicio 3.1

1.  Uno por uno y secuencialmente cada integrante del equipo descarga la copia centralizada del proyecto hace un cambio en alg√∫n archivo y lo sube de nuevo a GitHub

2.  Comprobad que el historial del proyecto tiene dos o tres nuevos commits, seg√∫n el n√∫mero de personas en el equipo

# Comandos avanzados de Git

## La he liado ¬øc√≥mo deshago los cambios?

Cuando hago un cambio que no quiero ¬øc√≥mo lo puedo resolver? Hay m√∫ltiples opciones pero aqu√≠ detallamos tres: *restore*, *reset* y *revert*. Restore se usa cuando no has llegado a hacer un commit con los cambios que quieres a√±adir y reset/revert cuando si has hecho un commit con los cambios.

-   `git restore`: deshace un `git add` y/o los cambios del directorio de trabajo.

    -   `git restore <nombre de archivo>`: descarta los cambios en un archivo al estado del √∫ltimo commit. ‚ö†Ô∏èEsta opci√≥n es peligrosa ya que borra los cambios no commitidos de tu directorio de trabajo.

    -   `git restore --staged <nombre de archivo>`: eliminar√° el archivo del √°rea de preparaci√≥n pero mantiene los cambios del directorio de trabajo.

-   `git reset`: deshace un `git commit` y/o un `git add` y/o los cambios del directorio de trabajo.

    -   `git reset --mixed HEAD~1`: deshace el add y el commit pero no los cambios realizados en el directorio de trabajo. Es equivalente a `git reset` (es decir, la opci√≥n por defecto). El HEAD\~1 significa el commit anterior al HEAD. Puedes ir un commit hacia atr√°s, dos, etc. Tambi√©n se puede utilizar el SHA en lugar del HEAD`~X` para ir a un commit espec√≠fico.

    -   `git reset --hard HEAD~1`: deshace el add, el commit y todos los cambios realizados en el directorio de trabajo. ‚ö†Ô∏è Esta es la opci√≥n m√°s PELIGROSA. Ten en cuenta que borra los cambios no commitidos de tu directorio de trabajo y apunta tu rama al commit especificado. Recomendamos ejecutar primero `git status` y ver si hay cambios no commitidos.

    -   `git reset --soft HEAD~1`: deshace el √∫ltimo commit pero no el add ni los cambios realizados en el directorio de trabajo.

![Diferencias entre git restore y distintos tipos de git reset](images/git_restore_reset.png)

-   `git revert HEAD`: es la opci√≥n segura de `git reset` para deshacer un commit ya que no resetea un proyecto a su estado anterior eliminando todos los commits posteriores (es decir, no elimina el historial de commits). Recomendamos usar `git reset` s√≥lo en ramas que no hayan sido compartidas todav√≠a (es decir, que no hayan sido commitidas a un repositorio remoto que otros est√©n usando). Resetear es cambiar el historial sin dejar rastro. Esto es siempre una mala pr√°ctica y puede causar problemas. Si queremos deshacer los cambios en las ramas que se comparten con otros, recomendamos utilizar el comando `git revert`. Con `git revert` quedar√° constancia de que se ha deshecho un cambio.

![Diferencias entre git revert y git reset](images/revert_reset.png)

### üìùEjercicio 3.2

El objetivo de este ejercicio es que veais las diferencias entre los distintos tipos de `git reset`. Para ello, tendr√©is que utilizar un comando para ver el estado de git despu√©s de cada `git reset`. ¬øOs acord√°is cu√°l era?

Cada integrante del equipo independientemente:

1.  Realiza algunos cambios en el repositorio
2.  Realiza un commit de los cambios y prueba hacer `git reset --soft HEAD~1`
3.  Realiza otro commit y prueba hacer `git reset --mixed HEAD~1`
4.  Realiza un √∫ltimo commit y prueba hacer `git reset --hard HEAD~1`

## Soluci√≥n de errores comunes en el flujo de trabajo

Git y GitHub permiten resolver problemas comunes en el trabajo colaborativo pero ¬°tambi√©n pueden causarnos bastantes quebraderos de cabeza! Es com√∫n que al intentar hacer `git push` no te deje porque alguno de tus colaboradores ya lo ha hecho antes (¬°y sin avisar!) y no tienes todos los cambios remotos integrados en tu repositorio local. Tambi√©n es frecuente olvidarse de hacer `git pull` al empezar a trabajar y guardar cambios importantes en el directorio de trabajo sin tener actualizado el proyecto con la copia remota. En este ultimo caso haz un *commit* con los cambios y antes de desesperar echa un ojo a este apartado.

Como resultado en ambos casos, el historial del repositorio remoto (A -\> B -\> C) y el local (A -\> B -\> D) habr√°n divergido y no se pueden juntar. Hay varias soluciones para este problema (<https://happygitwithr.com/pull-tricky.html>) y aqu√≠ hemos recogido s√≥lo una de ellas en la que el objetivo final es tener A -\> B -\> C+D. La soluci√≥n consiste en usar `git pull`. Como sabemos, este comando descarga los cambios y el historial del repositorio remoto y los incorpora en el repositorio local. Internamente `git pull` est√° compuesto por dos comandos:

-   `git fetch`: "trae" los cambios del repositorio remoto al local, pero no cambia los archivos locales (directorio de trabajo).

-   `git merge`: fusiona el nuevo historial y los cambios con lo que hab√≠a en el repositorio local. Es la misma idea que cuando fusionamos ramas.

Al hacer `git pull` en esta situaci√≥n pueden ocurrir dos cosas:

1.  No hay conflictos al fusionar ambos commits: ¬°solucionado!

2.  Aparecen conflictos en `git merge` porque C y D tienen cambios en las mismas partes de los mismos archivos. En este caso, hay que resolver los conflictos como vimos en la fusi√≥n de ramas, es decir, buscar los puntos de conflicto (`<<<<<<c√≥digo del main=======c√≥digo de la rama a unir>>>>>>)`, elegir la versi√≥n que corresponda, guardar el archivo y hacer de nuevo `git add`, `git commit` y `git push`.

‚ö°¬øC√≥mo prevenir que Git rechace `git push`? (<https://happygitwithr.com/push-rejected.html>) 1. Pushea tu trabajo con frecuencia. 2. Pullea el trabajo de otros tan pronto como te des cuenta que el repositorio remoto se ha actualizado. 3. ¬°Comunicate con tus colaboradores! 4. Usa ramas en lugar de trabajar en *main*.

### üìùEjercicio 3.3

Vamos a crear un conflicto en nuestro repositorio para despu√©s solucionarlo.

1.  Un miembro del equipo cambia la primera l√≠nea del archivo README.txt y lo sube a GitHub

2.  Sin hacer `git pull`, un segundo miembro del equipo cambia la misma l√≠nea del mismo archivo y lo sube a GitHub. ¬øQu√© error obtenemos? ¬øC√≥mo lo solucionamos?

3.  La segunda persona ejecuta `git pull` y entre todos resolveis el conflicto. ¬øC√≥mo es el historial del archivo ahora?

## Otros comandos √∫tiles

**Para facilitar el flujo de trabajo**:

-   `git add .`: registra todos los cambios a la vez

-   `git rm --cached filename`: elimina un archivo del √°rea de preparaci√≥n). Muy √∫til si has a√±adido un archivo de 10GB ‚ö†Ô∏è

-   `git stash`: cuando no quieres hacer un commit del trabajo a medio hacer o no est√°s seguro si lo quieres conservar pero quieres volver a este punto m√°s tarde. Crea un commit fuera de la linea principal de trabajo

-   `git apply`: recupera cualquier stash que has guardado

**Para obtener informaci√≥n**:

-   `git status`: muestra la rama en la que estamos y los cambios a√±adidos desde el √∫ltimo *commit*.

-   `git diff`: muestra los cambios no a√±adidos con `git add`

-   `git log`: muestra el historial de commit

-   `git branch -a`: muestra todas las ramas locales y remotas. Tambi√©n te indica en qu√© rama te encuentras

-   `git remote -v`: muestra una lista de repositorios remotos y su url

-   `git stash list`: ver los stash que has guardado

-   `gitk`: para visualizar la interfaz gr√°fica de Git <!--- V: Lo quitamos? No se si aporta mucho m√°s que lo que viene en RStudio -->

**Para mantener el orden en tu repositorio**:

-   `git branch -d <branchname>`: elimina la rama llamada "branchname" de tu pc

-   `git push origin --delete <branchname>`: elimina la rama remota llamada "branchname" (por ejemplo, desde GitHub). Ten en cuenta que la rama local y la remota no tienen nada que ver entre s√≠, por lo que deben eliminarse por separado

-   `git commit --amend -m "message"`: cambiar el mensaje del √∫ltimo commit

-   `git push --force`: se utiliza para sobreescribir la historia de la rama en la que est√°s trabajando. En este sentido, por ejemplo, se puede utilizar despu√©s de `git reset --hard` . ‚ö†Ô∏è‚ö†Ô∏èEsta opci√≥n es DOBLEMENTE PELIGROSA. No solo borras los cambios no commitidos si no que modificas la historia de un archivo. Si alg√∫n colaborador ya he descargado el archivo con su historia anterior, tendr√° problemas cuando quiera integrar sus cambios de nuevo. ¬°Utilizar s√≥lo en casos extremos! (p. ej. publico sin querer mis claves de acceso a alguna base de datos)

**Para integrar versiones anteriores**:

-   `git checkout HEAD~X`: para inspeccionar una versi√≥n (X) antigua del proyecto. Recomendamos crear una rama primero si se quiere a√±adir commits a partir de este punto temporal

-   `git cherry-pick SHA`: permite coger cualquier *commit* y fusionarlo con HEAD. Es √∫til si, por ejemplo, has hecho un commit en la rama equivocada y lo quieres mover a la correcta. Sin embargo, en general, un merge tradicional suele ser la mejor pr√°ctica (<https://www.atlassian.com/git/tutorials/cherry-pick>)

<details>

<summary>Session Info</summary>

```{r session-info}
Sys.time()
git2r::repository()
sessionInfo()
```

</details>
